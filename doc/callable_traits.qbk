[library CallableTraits
    [quickbook 1.6]
    [id callable_traits]
        [copyright 2016 Barrett Adair]
    [authors [Adair, Barrett]]
        [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE.md or copy at
        [@http://www.boost.org/LICENSE_1_0.txt http://www.boost.org/LICENSE_1_0.txt])
    ]
    [source-mode c++]
        [last-revision $Date$]
        [lang en]
]

[template library_name[][^CallableTraits]]
[template header_include_prefix[]callable_traits/]
[section:introduction Introduction]
[heading Quick Example]
[import ../example/intro.cpp]
[intro]

[section:motivation Motivation]

The complexity of callable types in C++ is extensive:

*function types
*function pointers
*function references
*objects with `operator()`
*objects with function pointer conversions
*[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html "abominable"] function types
*pointers to member data
*pointers to member functions
*qualified overloads of member functions: `const`, `volatile`, `&`, `&&`
*C-style varargs (`...`)
*calling conventions (`__cdecl`, `__stdcall`, `__fastcall`, `pascal`, etc.)
*`noexcept` ([@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0012r1.html part of the function type system in C++17])

[library_name] provides a comprehensive, uniform, and modern type-level interface for the manipulation and inspection of callable types in C++. By filling the gaps where existing library solutions fall short, [library_name] aims to provide such an exhaustive interface for the features listed above that library writers will *never again* need to specialize templates for callable types. [library_name] eliminates the need for horrific template specializations like these:

    template<typename Ret, typename T, typename... Args>
    struct foo<Ret(T::*)(Args..., ...) const volatile &&>{
                    //...
    };

Several library solutions exist to manipulate these types, or to abstract away their complexities. However, these solutions are occasionally inflexible or lacking in features, especially regarding function objects/lambdas. In [library_name], function pointers, function references, function types, abominable function types, member function pointers, member data pointers, function objects/lambdas, and references/pointers/smart pointers thereof are generally interchangeable.

The use cases for [library_name] are closely related to those of [@http://www.boost.org/doc/libs/1_60_0/libs/type_traits/doc/html/boost_typetraits/reference/function_traits.html function_traits] and [@http://www.boost.org/doc/libs/1_60_0/libs/function_types/doc/html/index.html FunctionTypes].

[important [library_name] currently offers no interface for the manipulation of calling conventions. Also, no features are currently implemented to account for C++17's `noexcept`. These features are planned for future versions on supported platforms.]

[endsect]

[section:ten_reasons 10 reasons to use [library_name]]

# [library_name]' template aliases and `constexpr` `std::integral_constant` functions are preferable to `typename foo::type` and `foo::value`

# [library_name] offers a familar, consistent interface for the synthesis and decomposition of callable types
        * e.g. `remove_function_const` parallels `std::remove_const`

# universal references are accepted everywhere, so you don't need to worry about using `std::remove_reference` first

# function object pointers/ pointers are accepted (when `INVOKE` is not an immediate concern)

# `arg_at<2, Callable>` is better than `typename function_traits<Callable>::arg2_type`

# function objects are first-class citizens in [library_name]
        * e.g. `result_of` can accept a function object

# `is_constexpr` lets you check whether a function, member function, or function object is `constexpr`

# `can_invoke` lets you test `INVOKE`-ability at compile-time using value semantics

# `can_invoke_constexpr` adds a `constexpr`-ness check to `can_invoke`

# `min_arity` can be used to detect default arguments of a function object

[endsect]

[section:function_sugar Use case: `std::function` sugar]

At the time of this writing, there are 260 [@http://stackoverflow.com/search?q=convert+std%3A%3Abind+to+std%3A%3Afunction search results] on Stack Overflow concerning the conversion from `std::bind` to `std::function`. There are 336 [@http://stackoverflow.com/search?q=convert+lambda+to+std%3A%3Afunction search results] concerning the conversion of lambdas to `std::function`. With this example, we'll kill both birds with the same stone. The `make_function` function defined below will leverage [library_name] to...

# Create an `std::function<T>` where T is not explicitly supplied by the user
# Create an `std::function<T>` where T is the deduced "signature" of an `std::placeholders` expression.

Without real-world context, `make_function` may seem rather silly to those who know the runtime costs of type erasure. However, whenever `std::function` is required by some 3rd party API, this example might make a bit more sense.

[import ../example/make_function.cpp]
[make_function]

[endsect]

[endsect]



[template ct_open_include[]    `#include<`[^[header_include_prefix]]]
[template ct_close_include[]`.hpp>`]
[template include_header[name][ct_open_include][^[name]][ct_close_include][br]]



[section:headers Headers]

The simplest way to use [library_name] is to include the main header file:

[include_header callable_traits]

[library_name] interface is also broken down by trait into individual header files. To use only the traits you need, include one or more of the following headers, listed alphabetically:

[include_header [link callable_traits.ref_add_function_const add_function_const]]
[include_header [link callable_traits.ref_add_function_cv add_function_cv]]
[include_header [link callable_traits.ref_add_function_lvalue add_function_lvalue]]
[include_header [link callable_traits.ref_add_function_rvalue add_function_rvalue]]
[include_header [link callable_traits.ref_add_varargs add_varargs]]
[include_header [link callable_traits.ref_add_function_volatile add_function_volatile]]
[include_header [link callable_traits.ref_apply_member_pointer apply_member_pointer]]
[include_header [link callable_traits.ref_apply_return apply_return]]
[include_header [link callable_traits.ref_arg_at arg_at]]
[include_header [link callable_traits.ref_args args]]
[include_header [link callable_traits.ref_arity arity]]
[include_header [link callable_traits.ref_bind bind]]
[include_header [link callable_traits.ref_can_invoke can_invoke]]
[include_header [link callable_traits.ref_can_invoke_constexpr can_invoke_constexpr]]
[include_header [link callable_traits.ref_function_type function_type]]
[include_header [link callable_traits.ref_has_varargs has_varargs]]
[include_header [link callable_traits.ref_has_void_return has_void_return]]
[include_header [link callable_traits.ref_is_const_qualified is_const_qualified]]
[include_header [link callable_traits.ref_is_constexpr is_constexpr]]
[include_header [link callable_traits.ref_is_lvalue_qualified is_lvalue_qualified]]
[include_header [link callable_traits.ref_is_reference_qualified is_reference_qualified]]
[include_header [link callable_traits.ref_is_rvalue_qualified is_rvalue_qualified]]
[include_header [link callable_traits.ref_is_unqualified is_unqualified]]
[include_header [link callable_traits.ref_is_volatile_qualified is_volatile_qualified]]
[include_header [link callable_traits.ref_max_arity max_arity]]
[include_header [link callable_traits.ref_min_arity min_arity]]
[include_header [link callable_traits.ref_qualified_function_type qualified_function_type]]
[include_header [link callable_traits.ref_remove_function_const remove_function_const]]
[include_header [link callable_traits.ref_remove_function_cv remove_function_cv]]
[include_header [link callable_traits.ref_remove_member_pointer remove_member_pointer]]
[include_header [link callable_traits.ref_remove_function_reference remove_function_reference]]
[include_header [link callable_traits.ref_remove_varargs remove_varargs]]
[include_header [link callable_traits.ref_remove_function_volatile remove_function_volatile]]
[include_header [link callable_traits.ref_result_of result_of]]

[endsect]



[section:ref_add_function_const add_function_const]
TODO
[heading Example]
[import ../example/add_function_const.cpp]
[add_function_const]
[endsect]

[section:ref_add_function_cv add_function_cv]
TODO
[heading Example]
[import ../example/add_function_cv.cpp]
[add_function_cv]
[endsect]

[section:ref_add_function_lvalue add_function_lvalue]
TODO
[import ../example/add_function_lvalue.cpp]
[add_function_lvalue]
[endsect]

[section:ref_add_function_rvalue add_function_rvalue]
TODO
[import ../example/add_function_rvalue.cpp]
[add_function_rvalue]
[endsect]

[section:ref_add_varargs add_varargs]
TODO
[import ../example/add_varargs.cpp]
[add_varargs]
[endsect]

[section:ref_add_function_volatile add_function_volatile]
TODO
[endsect]

[section:ref_apply_member_pointer apply_member_pointer]
TODO
[heading Example]
[import ../example/apply_member_pointer.cpp]
[apply_member_pointer]
[endsect]

[section:ref_apply_return apply_return]
TODO
[heading Example]
[/import ../example/apply_return.cpp]
[apply_return]
[endsect]

[section:ref_arg_at arg_at]
TODO
[heading Example]
[/import ../example/arg_at.cpp]
[arg_at]
[endsect]

[section:ref_args args]
TODO
[heading Example]
[import ../example/args.cpp]
[args]
[endsect]

[section:ref_arity arity]
TODO
[heading Example]
[/import ../example/arity.cpp]
[arity]
[endsect]

[section:ref_bind bind]
TODO
[heading Example 1]
[import ../example/bind_1.cpp]
[bind_1]
[heading Example 2]
[import ../example/bind_2.cpp]
[bind_2]
[endsect]

[section:ref_can_invoke can_invoke]
TODO
[heading Example - Function Object]
[import ../example/can_invoke_function_object.cpp]
[can_invoke_function_object]
[heading Example - Member Function Pointer]
[import ../example/can_invoke_member_function_pointer.cpp]
[can_invoke_member_function_pointer]
[heading Example - Function Pointer]
[import ../example/can_invoke_function_pointer.cpp]
[can_invoke_function_pointer]
[heading Example - Function Reference]
[import ../example/can_invoke_function_reference.cpp]
[can_invoke_function_reference]
[endsect]

[section:ref_can_invoke_constexpr can_invoke_constexpr]
TODO
[heading Example - Function Object]
[import ../example/can_invoke_constexpr_function_object.cpp]
[can_invoke_constexpr_function_object]
[heading Example - Member Function Pointer]
[import ../example/can_invoke_constexpr_member_function_pointer.cpp]
[can_invoke_constexpr_member_function_pointer]
[heading Example - Function Pointer]
[import ../example/can_invoke_constexpr_function_pointer.cpp]
[can_invoke_constexpr_function_pointer]
[endsect]

[section:ref_function_type function_type]
TODO
[heading Example]
[import ../example/function_type.cpp]
[function_type]
[endsect]

[section:ref_has_varargs has_varargs]
TODO
[heading Example]
[/import ../example/has_varargs.cpp]
[has_varargs]
[endsect]

[section:ref_has_void_return has_void_return]
TODO
[heading Example]
[/import ../example/has_void_return.cpp]
[has_void_return]
[endsect]

[section:ref_is_const_qualified is_const_qualified]
TODO
[heading Example]
[/import ../example/is_const_qualified.cpp]
[is_const_qualified]
[endsect]

[section:ref_is_constexpr is_constexpr]
TODO
[heading Example - Function Object]
[import ../example/is_constexpr_function_object.cpp]
[is_constexpr_function_object]
[heading Example - Function Pointer]
[import ../example/is_constexpr_function_pointer.cpp]
[is_constexpr_function_pointer]
[endsect]

[section:ref_is_lvalue_qualified is_lvalue_qualified]
TODO
[heading Example]
[/import ../example/is_lvalue_qualified.cpp]
[is_lvalue_qualified]
[endsect]

[section:ref_is_reference_qualified is_reference_qualified]
TODO
[heading Example]
[/import ../example/is_reference_qualified.cpp]
[is_reference_qualified]
[endsect]

[section:ref_is_rvalue_qualified is_rvalue_qualified]
TODO
[heading Example]
[/import ../example/is_rvalue_qualified.cpp]
[is_rvalue_qualified]
[endsect]

[section:ref_is_unqualified is_unqualified]
TODO
[heading Example]
[/import ../example/is_unqualified.cpp]
[is_unqualified]
[endsect]

[section:ref_is_volatile_qualified is_volatile_qualified]
TODO
[heading Example]
[/import ../example/is_volatile_qualified.cpp]
[is_volatile_qualified]
[endsect]

[section:ref_max_arity max_arity]
TODO
[heading Example]
[/import ../example/max_arity.cpp]
[max_arity]
[endsect]

[section:ref_min_arity min_arity]
TODO
[heading Example]
[/import ../example/min_arity.cpp]
[min_arity]
[endsect]

[section:ref_qualified_function_type qualified_function_type]
TODO
[heading Example]
[/import ../example/qualified_function_type.cpp]
[qualified_function_type]
[endsect]

[section:ref_remove_function_const remove_function_const]
TODO
[heading Example]
[/import ../example/remove_function_const.cpp]
[remove_function_const]
[endsect]

[section:ref_remove_function_cv remove_function_cv]
TODO
[heading Example]
[/import ../example/remove_function_cv.cpp]
[remove_function_cv]
[endsect]

[section:ref_remove_member_pointer remove_member_pointer]
TODO
[heading Example]
[import ../example/remove_member_pointer.cpp]
[remove_member_pointer]
[endsect]

[section:ref_remove_function_reference remove_function_reference]
TODO
[heading Example]
[/import ../example/remove_function_reference.cpp]
[remove_function_reference]
[endsect]

[section:ref_remove_varargs remove_varargs]
TODO
[heading Example]
[/import ../example/remove_varargs.cpp]
[remove_varargs]
[endsect]

[section:ref_remove_function_volatile remove_function_volatile]
TODO
[heading Example]
[/import ../example/remove_function_volatile.cpp]
[remove_function_volatile]
[endsect]

[section:ref_result_of result_of]
TODO
[heading Example]
[import ../example/result_of.cpp]
[result_of]
[endsect]

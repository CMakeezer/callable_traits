[library CallableTraits
    [quickbook 1.6]
    [id callable_traits]
        [copyright 2016 Barrett Adair]
    [authors [Adair, Barrett]]
        [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE.md or copy at
        [@http://www.boost.org/LICENSE_1_0.txt http://www.boost.org/LICENSE_1_0.txt])
    ]
    [source-mode c++]
        [last-revision $Date$]
        [lang en]
]

[/ Boost developer: you should enable word wrap before you read further]

[template libname[][^CallableTraits]]
[template libns[][^callable_traits::]]
[template header_include_prefix[]callable_traits/]
[template detail_open_include[]    `#include<`[^[header_include_prefix]]]
[template detail_close_include[]`.hpp>`]
[template include_header[name][detail_open_include][^[name]][detail_close_include][br]]
[template invoke[][@http://en.cppreference.com/w/cpp/utility/functional/invoke INVOKE]]

[/ *** concepts *** ]

[template fn_obj[][role green FunctionObject]]
[template overloaded_fn_obj[][role green OverloadedFunctionObject]]
[template simple_fn_obj[][role green SimpleFunctionObject]]
[template pmf[][role green MemberFunctionPtr]]
[template pmd[][role green MemberDataPtr]]
[template member_ptr[][role green MemberPtr]]
[template fn[][role green Function]]
[template abominable[][role green AbominableFunction]]
[template fn_ptr[][role green FunctionPtr]]
[template fn_ref[][role green FunctionReference]]
[template simple_callable[][role green SimpleCallable]]
[template simple_invokable[][role green SimpleInvokable]]
[template callable[][role green Callable]]
[template invokable[][role green Invokable]]
[template constexpr_constructible[][role green ConstexprDefaultConstructible]]


[section:introduction Introduction]

[libname] provides a comprehensive, uniform, and modern type-level interface for the inspection, decomposition, and synthesis of C++ callable types. This documentation will be most beneficial to readers with a basic understanding of the syntax and usage of the following C++ features:

* [@http://en.cppreference.com/w/cpp/language/partial_specialization template specializations]
* [@http://en.cppreference.com/w/cpp/language/sfinae SFINAE]
* [invoke] rules
* function types
* [@http://en.cppreference.com/w/cpp/language/pointer#Pointers_to_functions function pointers]
* [@http://stackoverflow.com/questions/480248/function-references function references]
* [@http://en.cppreference.com/w/cpp/language/pointer#Pointers_to_member_functions pointers to member functions]
* [@http://en.cppreference.com/w/cpp/language/pointer#Pointers_to_data_members pointers to data members]
* [@http://en.cppreference.com/w/cpp/language/operators#Function_call_operator the function call operator, [^operator()]]
* [@https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers universal references] and [@http://stackoverflow.com/questions/13725747/concise-explanation-of-reference-collapsing-rules-requested-1-a-a-2 reference collapsing rules]
* [@http://en.cppreference.com/w/cpp/language/member_functions#const-.2C_volatile-.2C_and_ref-qualified_member_functions cv-qualified and ref-qualified member functions]
* [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html "abominable" function types]
* [@http://en.cppreference.com/w/cpp/language/overloaded_address taking the address of an overloaded function]
* [@http://en.cppreference.com/w/c/language/variadic C-style variadics], a.k.a. `varargs`
* [@https://en.wikipedia.org/wiki/X86_calling_conventions calling conventions]

[section Quick Example]
[import ../example/intro.cpp]
[intro]
[endsect]

[section:motivation Motivation]

Several library solutions exist to manipulate functions or callable types. However, none of these are comprehensive, and many of them have not aged well with the advent of modern C++. [libname] fills the gaps found in existing solutions, and improves upon them wherever possible.

Consider for a moment this rather hideous template specialization:


[import ./hideous_template.snippet.cpp]
[hideous_template]

Potential use cases for such obscure specializations are vitually nonexistent in run-of-the-mill C++ application codebases. Even in library code, these are exceedingly rare. However, there are a handful of  specific problems in C++ that cannot be solved by any other means. While rare, a correct and generic implementation of these templates is tedious and time consuming. [libname] premises that these rare cases necessitate a library solution. One goal of [libname] is to [*completely and decisively eliminate the need for function signature template specializations]. To the knowledge of the author, [libname] is the first and only library solution to attempt this.

The use cases for [libname] are closely related to those of [@http://www.boost.org/doc/libs/1_60_0/libs/type_traits/doc/html/boost_typetraits/reference/function_traits.html function_traits] and [@http://www.boost.org/doc/libs/1_60_0/libs/function_types/doc/html/index.html FunctionTypes].

[important The upcoming C++17 ISO standard includes a [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0012r1.html change to the core language] which adds [^noexcept] to function signatures. Currently, this is not handled in [libname]. New features to account for this change are planned in [libname], which the author intends to add, with regard for backwards compatibility, as soon as the language change is implemented in a major compiler. ]

[endsect]

[section:basic_concepts Concept Definitions]

[heading [fn_ptr]]
* Any function pointer type
* May be cv-qualified and/or ref-qualified
* e.g. `void(*)(int, int)`

[heading [fn_ref]]
* Any function reference type
* e.g. `void(&)(int, int)`

[heading [fn]]
* Any unqualified function type
* e.g. `void(int, int)`

[heading [abominable]]
* Any qualified (a.k.a. [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html "abominable"]) function type
* Not technically "callable", but still falls under the [libname] umbrella
* Mutually exclusive with [fn]
* e.g. `void(int, int) const`

[heading [pmf]]
* Any pointer to member function type
* The pointer type may be cv-qualified and/or ref-qualified
* e.g. `void (foo::*)(int, int)`

[heading [pmd]]
* Any pointer to data member type
* The pointer type may be cv-qualified and/or ref-qualified
* e.g. `int foo::*`

[heading [simple_fn_obj]]
* Any class/struct with a ['non-templated, non-overloaded] function call operator
* Includes non-generic lambda types
* May be cv-qualified and/or ref-qualified.
* Mutually exclusive with [overloaded_fn_obj]
* e.g. the type of this lambda: `[](int x, int y) { return x + y; }`

[heading [overloaded_fn_obj]]
* Any class/struct with a ['templated or overloaded] function call operator, with the following limitation for those with templated function call operators (which includes generic lambdas):
  * If templated , all instantiations must be [@http://stackoverflow.com/questions/35033306/what-does-it-mean-when-one-says-something-is-sfinae-friendly SFINAE-friendly], and must not use [@http://en.cppreference.com/w/cpp/language/dependent_name dependent names], except where the dependent "names" are C++ operators.
* May be cv-qualified and/or ref-qualified
* e.g. the type of this generic lambda: `[](auto x, auto y) { return x + y; }`

[warning Generic lambdas or classes with templated function objects that are either not SFINAE-friendly or rely on dependent names for template instantiations are generally incompatible with [libname].]

[heading [fn_obj]]
* Any type that is either an [overloaded_fn_obj] or a [simple_fn_obj]

[heading [callable]]
* The superset of the following:
  * [fn_ptr]
  * [fn_ref]
  * [fn]
  * [abominable]
  * [pmf]
  * [pmd]
  * [fn_obj]

[heading [simple_callable]]
* Includes all [callable] types, [*except for [overloaded_fn_obj]]

[heading [simple_invokable]]
* Includes all [callable] types, [*except for [overloaded_fn_obj], [fn], and [abominable]]

[heading [invokable]]
* Includes all [callable] types, [*except for [fn] and [abominable]]

[heading [constexpr_constructble]]
* Any [@http://en.cppreference.com/w/cpp/concept/LiteralType LiteralType] that is also default-constructible

[endsect]

[section:reasons Why use [libname]?]

[*1.] [libname] offers template aliases such as `remove_function_const` for manipulating function qualifiers, designed to parallel the `<type_traits>` aliases such as `std::remove_const_t`.

[*2.] [libname] is designed to accept cv-qualified and ref-qualified types, which eliminates the need to prepare template argument types with metafunctions such as `std::remove_reference` and `std::decay`. This is especially useful when dealing with perfectly-forwarded parameter types in function templates.

[*3.] [libname] is designed in terms of the [invoke] rules, with one unobtrusive and beneficial deviation: [fn] types and [abominable] types are compatible with all operations that do not specifically require an invocation.

[*4.] [libns]`arg_at<2, Callable>` is both more flexible and more readable than `typename boost::function_traits<Callable>::arg3_type`.

[*5.] [libns]`can_invoke` can be used to test `INVOKE`-ability at compile-time, with value semantics. For the craziest metaprogrammers, [libns]`can_invoke_constexpr` does the same as `can_invoke` for [constexpr_constructible] types, with an added check for `constexpr`-ness (Note: for `can_invoke_constexpr`, argument types must also be [constexpr_constructible])

[*6.] [libns]`is_constexpr` can be used to check whether a [constexpr_constructible] type is a [callable] type that yields a `constexpr` result -- no arguments necessary.

[*7.] [libns]`bind` can be used by library writers to easily accept `std::placeholder` expressions anywhere, without requiring the user to `std::bind` them first. Library writers can then decide to use `std::bind`, `boost::bind`, or whatever implementation suits their needs. Either way, it allows for the creation of more flexible APIs, where a function template taking a "callable type" can be overloaded to also accept placeholder expressions. It's perhaps a small improvement from requiring `std::bind` first, but in API design, even the smallest things count.

[*8.] [libns]`min_arity` can be used to detect the presence of default arguments on a [simple_fn_obj]

[*9.] The [libname] interface mainly consists of template aliases and `constexpr std::integral_constant` functions, which are arguably preferable to `typename foo::type` and `foo::value`. While the `std::integral_constant` functions in [libname] may be a deviation from traditional type trait designs, they facilitate a metaprogramming style that uses value-semantics (a la [@https://boostorg.github.io/hana/ [^Boost.Hana]]). The functions can generally be used with either types or values, which eliminates unnecessary `decltype` usage.

[*10.] [libname] includes optional features for the manipulation and inspection of calling conventions. These features are currently deemed experimental, because they greatly increase the test surface of [libname], are platform-specific, and are not yet fully tested on any platform.

[endsect]

[section:function_sugar Use case: `std::function` sugar]

At the time of this writing, there are around 260 [@http://stackoverflow.com/search?q=convert+std%3A%3Abind+to+std%3A%3Afunction search results] on Stack Overflow concerning the conversion from `std::bind` to `std::function`. There are roughly 340 [@http://stackoverflow.com/search?q=convert+lambda+to+std%3A%3Afunction search results] concerning the conversion of lambdas to `std::function`. In the example below, we'll kill both birds with the same stone. The `make_function` function will leverage [libname] to...

# Create an `std::function<T>` where T is not explicitly supplied by the user
# Create an `std::function<T>` where T is the deduced "signature" of an `std::placeholders` expression.

Without real-world context, `make_function` may seem rather silly to those who know the runtime costs of type erasure. However, whenever `std::function` is required by some 3rd party API, this example might make a bit more sense.

[import ../example/make_function.cpp]
[make_function]

[endsect]

[endsect]

[section:headers Headers]

The simplest way to use [libname] is to include the main header file:

[include_header callable_traits]

[libname] interface is also broken down by trait into individual header files. To use only the traits you need, include one or more of the following headers, listed alphabetically:

[include_header [link callable_traits.ref_add_calling_convention add_calling_convention]]
[include_header [link callable_traits.ref_add_function_const add_function_const]]
[include_header [link callable_traits.ref_add_function_cv add_function_cv]]
[include_header [link callable_traits.ref_add_function_lvalue add_function_lvalue]]
[include_header [link callable_traits.ref_add_function_rvalue add_function_rvalue]]
[include_header [link callable_traits.ref_add_varargs add_varargs]]
[include_header [link callable_traits.ref_add_function_volatile add_function_volatile]]
[include_header [link callable_traits.ref_apply_member_pointer apply_member_pointer]]
[include_header [link callable_traits.ref_apply_return apply_return]]
[include_header [link callable_traits.ref_arg_at arg_at]]
[include_header [link callable_traits.ref_args args]]
[include_header [link callable_traits.ref_arity arity]]
[include_header [link callable_traits.ref_bind bind]]
[include_header [link callable_traits.ref_can_invoke can_invoke]]
[include_header [link callable_traits.ref_can_invoke_constexpr can_invoke_constexpr]]
[include_header [link callable_traits.ref_function_type function_type]]
[include_header [link callable_traits.ref_has_calling_convention has_calling_convention]]
[include_header [link callable_traits.ref_has_varargs has_varargs]]
[include_header [link callable_traits.ref_has_void_return has_void_return]]
[include_header [link callable_traits.ref_is_const_qualified is_const_qualified]]
[include_header [link callable_traits.ref_is_constexpr is_constexpr]]
[include_header [link callable_traits.ref_is_lvalue_qualified is_lvalue_qualified]]
[include_header [link callable_traits.ref_is_reference_qualified is_reference_qualified]]
[include_header [link callable_traits.ref_is_rvalue_qualified is_rvalue_qualified]]
[include_header [link callable_traits.ref_is_unqualified is_unqualified]]
[include_header [link callable_traits.ref_is_volatile_qualified is_volatile_qualified]]
[include_header [link callable_traits.ref_max_arity max_arity]]
[include_header [link callable_traits.ref_min_arity min_arity]]
[include_header [link callable_traits.ref_qualified_function_type qualified_function_type]]
[include_header [link callable_traits.ref_remove_calling_convention remove_calling_convention]]
[include_header [link callable_traits.ref_remove_function_const remove_function_const]]
[include_header [link callable_traits.ref_remove_function_cv remove_function_cv]]
[include_header [link callable_traits.ref_remove_member_pointer remove_member_pointer]]
[include_header [link callable_traits.ref_remove_function_reference remove_function_reference]]
[include_header [link callable_traits.ref_remove_varargs remove_varargs]]
[include_header [link callable_traits.ref_remove_function_volatile remove_function_volatile]]
[include_header [link callable_traits.ref_result_of result_of]]

[endsect]



[section:ref_add_calling_convention add_calling_convention]
`add_calling_convention<T, CcTag` will add a calling conventions to a pointer type, where `T` is a [fn_ptr] or [pmf], and `CcTag` is one of the following types:

*[libns]`cdecl_tag`
*[libns]`stdcall_tag`
*[libns]`fastcall_tag`
*[libns]`pascal_tag`

For `add_calling_convention` to actually work, you must:


# Be programming on a supported platform
# Add the calling convention to a pointer type where the platform allows you to do so
# Before including any [libname] headers, you must first define the appropriate macro(s) to enable the desired calling convention(s):
 * `CALLABLE_TRAITS_ENABLE_CDECL` for `__cdecl`
 * `CALLABLE_TRAITS_ENABLE_STDCALL` for `__stdcall`
 * `CALLABLE_TRAITS_ENABLE_FASTCALL` for `__fastcall`
 * `CALLABLE_TRAITS_ENABLE_PASCAL` for `pascal`

[warning This feature is currently considered experimental. Your feedback and advice is much appreciated! ]
[heading Example - [^__fastcall] to [^__stdcall]]
[import ../example/experimental_changing_calling_conventions.cpp]
[experimental_changing_calling_conventions]
[heading Example - [^__cdecl]]
[import ../example/experimental_calling_convention_cdecl.cpp]
[calling_convention_cdecl]

[endsect]

[section:ref_add_function_const add_function_const]
TODO
[heading Example]
[import ../example/add_function_const.cpp]
[add_function_const]
[endsect]

[section:ref_add_function_cv add_function_cv]
TODO
[heading Example]
[import ../example/add_function_cv.cpp]
[add_function_cv]
[endsect]

[section:ref_add_function_lvalue add_function_lvalue]
TODO
[import ../example/add_function_lvalue.cpp]
[add_function_lvalue]
[endsect]

[section:ref_add_function_rvalue add_function_rvalue]
TODO
[import ../example/add_function_rvalue.cpp]
[add_function_rvalue]
[endsect]

[section:ref_add_varargs add_varargs]
TODO
[import ../example/add_varargs.cpp]
[add_varargs]
[endsect]

[section:ref_add_function_volatile add_function_volatile]
TODO
[endsect]

[section:ref_apply_member_pointer apply_member_pointer]
TODO
[heading Example]
[import ../example/apply_member_pointer.cpp]
[apply_member_pointer]
[endsect]

[section:ref_apply_return apply_return]
TODO
[heading Example]
[/import ../example/apply_return.cpp]
[apply_return]
[endsect]

[section:ref_arg_at arg_at]
TODO
[heading Example]
[/import ../example/arg_at.cpp]
[arg_at]
[endsect]

[section:ref_args args]
TODO
[heading Example]
[import ../example/args.cpp]
[args]
[endsect]

[section:ref_arity arity]
TODO
[heading Example]
[/import ../example/arity.cpp]
[arity]
[endsect]

[section:ref_bind bind]
TODO
[heading Example 1]
[import ../example/bind_1.cpp]
[bind_1]
[heading Example 2]
[import ../example/bind_2.cpp]
[bind_2]
[endsect]

[section:ref_can_invoke can_invoke]
TODO
[heading Example - Function Object]
[import ../example/can_invoke_function_object.cpp]
[can_invoke_function_object]
[heading Example - Member Function Pointer]
[import ../example/can_invoke_member_function_pointer.cpp]
[can_invoke_member_function_pointer]
[heading Example - Function Pointer]
[import ../example/can_invoke_function_pointer.cpp]
[can_invoke_function_pointer]
[heading Example - Function Reference]
[import ../example/can_invoke_function_reference.cpp]
[can_invoke_function_reference]
[endsect]

[section:ref_can_invoke_constexpr can_invoke_constexpr]
TODO
[heading Example - Function Object]
[import ../example/can_invoke_constexpr_function_object.cpp]
[can_invoke_constexpr_function_object]
[heading Example - Member Function Pointer]
[import ../example/can_invoke_constexpr_member_function_pointer.cpp]
[can_invoke_constexpr_member_function_pointer]
[heading Example - Function Pointer]
[import ../example/can_invoke_constexpr_function_pointer.cpp]
[can_invoke_constexpr_function_pointer]
[endsect]

[section:ref_function_type function_type]
TODO
[heading Example]
[import ../example/function_type.cpp]
[function_type]
[endsect]

[section:ref_has_calling_convention has_calling_convention]
TODO
[heading Example - [^__fastcall] to [^__stdcall]]
[experimental_changing_calling_conventions]
[endsect]

[section:ref_has_varargs has_varargs]
TODO
[heading Example]
[/import ../example/has_varargs.cpp]
[has_varargs]
[endsect]

[section:ref_has_void_return has_void_return]
TODO
[heading Example]
[/import ../example/has_void_return.cpp]
[has_void_return]
[endsect]

[section:ref_is_const_qualified is_const_qualified]
TODO
[heading Example]
[/import ../example/is_const_qualified.cpp]
[is_const_qualified]
[endsect]

[section:ref_is_constexpr is_constexpr]
TODO
[heading Example - Function Object]
[import ../example/is_constexpr_function_object.cpp]
[is_constexpr_function_object]
[heading Example - Function Pointer]
[import ../example/is_constexpr_function_pointer.cpp]
[is_constexpr_function_pointer]
[endsect]

[section:ref_is_lvalue_qualified is_lvalue_qualified]
TODO
[heading Example]
[/import ../example/is_lvalue_qualified.cpp]
[is_lvalue_qualified]
[endsect]

[section:ref_is_reference_qualified is_reference_qualified]
TODO
[heading Example]
[/import ../example/is_reference_qualified.cpp]
[is_reference_qualified]
[endsect]

[section:ref_is_rvalue_qualified is_rvalue_qualified]
TODO
[heading Example]
[/import ../example/is_rvalue_qualified.cpp]
[is_rvalue_qualified]
[endsect]

[section:ref_is_unqualified is_unqualified]
TODO
[heading Example]
[/import ../example/is_unqualified.cpp]
[is_unqualified]
[endsect]

[section:ref_is_volatile_qualified is_volatile_qualified]
TODO
[heading Example]
[/import ../example/is_volatile_qualified.cpp]
[is_volatile_qualified]
[endsect]

[section:ref_max_arity max_arity]
TODO
[heading Example]
[/import ../example/max_arity.cpp]
[max_arity]
[endsect]

[section:ref_min_arity min_arity]
TODO
[heading Example]
[/import ../example/min_arity.cpp]
[min_arity]
[endsect]

[section:ref_qualified_function_type qualified_function_type]
TODO
[heading Example]
[/import ../example/qualified_function_type.cpp]
[qualified_function_type]
[endsect]

[section:ref_remove_calling_convention remove_calling_convention]
TODO
[heading Example - [^__fastcall] to [^__stdcall]]
[experimental_changing_calling_conventions]
[endsect]

[section:ref_remove_function_const remove_function_const]
TODO
[heading Example]
[/import ../example/remove_function_const.cpp]
[remove_function_const]
[endsect]

[section:ref_remove_function_cv remove_function_cv]
TODO
[heading Example]
[/import ../example/remove_function_cv.cpp]
[remove_function_cv]
[endsect]

[section:ref_remove_member_pointer remove_member_pointer]
TODO
[heading Example]
[import ../example/remove_member_pointer.cpp]
[remove_member_pointer]
[endsect]

[section:ref_remove_function_reference remove_function_reference]
TODO
[heading Example]
[/import ../example/remove_function_reference.cpp]
[remove_function_reference]
[endsect]

[section:ref_remove_varargs remove_varargs]
TODO
[heading Example]
[/import ../example/remove_varargs.cpp]
[remove_varargs]
[endsect]

[section:ref_remove_function_volatile remove_function_volatile]
TODO
[heading Example]
[/import ../example/remove_function_volatile.cpp]
[remove_function_volatile]
[endsect]

[section:ref_result_of result_of]
TODO
[heading Example]
[import ../example/result_of.cpp]
[result_of]
[endsect]


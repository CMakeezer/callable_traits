[article CallableTraits
    [quickbook 1.6]
    [id callable_traits]
        [copyright 2016 Barrett Adair]
    [authors [Adair, Barrett]]
        [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE.md or copy at
        [@http://www.boost.org/LICENSE_1_0.txt http://www.boost.org/LICENSE_1_0.txt])
    ]
    [source-mode c++]
        [last-revision $Date$]
        [lang en]
]



[/ developer: you should enable word wrap before you read further]




[template libname[][^CallableTraits]]
[template lib_namespace[][^callable_traits]]
[template namespace_scoped[][^callable_traits::]]
[template header_include_prefix[]callable_traits/]
[template detail_open_include[]    `#include<`[^[header_include_prefix]]]
[template detail_close_include[]`.hpp>`]
[template include_header[name][detail_open_include][^[name]][detail_close_include]]
[template invoke[][@http://en.cppreference.com/w/cpp/utility/functional/invoke [^['INVOKE]]]]
[template hana[][@https://boostorg.github.io/hana/ [^Boost.Hana]]]
[template feedback[][link callable_traits.contact feedback]]
[template repo[][@https://github.com/badair/callable_traits GitHub]]

[template link_msvc_issues[][link callable_traits.compatibility.msvc_issues MSVC Issues]]

[/ *** these templates are used to turn concept names green ***]
[template concept_fn_ptr[][role green FunctionPtr]]
[template concept_fn_ref[][role green FunctionReference]]
[template concept_simple_fn[][role green UnqualifiedFunction]]
[template concept_abominable[][role green AbominableFunction]]
[template concept_fn[][role green Function]]
[template concept_pmf[][role green MemberFunctionPtr]]
[template concept_pmd[][role green MemberDataPtr]]
[template concept_member_ptr[][role green MemberPtr]]
[template concept_simple_fn_obj[][role green SimpleFunctionObject]]
[template concept_overloaded_fn_obj[][role green OverloadedFunctionObject]]
[template concept_fn_obj[][role green FunctionObject]]
[template concept_simple_callable[][role green SimpleCallable]]
[template concept_simple_invokable[][role green SimpleInvokable]]
[template concept_callable[][role green Callable]]
[template concept_invokable[][role green Invokable]]
[template concept_bind_expression[][role green BindExpression]]
[template concept_signature[][role green Signature]]
[template concept_constexpr_constructible[][role green ConstexprDefaultConstructible]]
[template concept_cc_tag[][role green CallingConventionTag]]

[/ *** concept links *** ]
[template link_fn_ptr[][link callable_traits.concepts.ref_fn_ptr [concept_fn_ptr]]]
[template link_fn_ref[][link callable_traits.concepts.ref_fn_ref [concept_fn_ref]]]
[template link_simple_fn[][link callable_traits.concepts.ref_simple_fn [concept_simple_fn]]]
[template link_abominable[][link callable_traits.concepts.ref_abominable [concept_abominable]]]
[template link_fn[][link callable_traits.concepts.ref_fn [concept_fn]]]
[template link_pmf[][link callable_traits.concepts.ref_pmf [concept_pmf]]]
[template link_pmd[][link callable_traits.concepts.ref_pmd [concept_pmd]]]
[template link_member_ptr[][link callable_traits.concepts.ref_member_ptr [concept_member_ptr]]]
[template link_simple_fn_obj[][link callable_traits.concepts.ref_simple_fn_obj [concept_simple_fn_obj]]]
[template link_overloaded_fn_obj[][link callable_traits.concepts.ref_overloaded_fn_obj [concept_overloaded_fn_obj]]]
[template link_fn_obj[][link callable_traits.concepts.ref_fn_obj [concept_fn_obj]]]
[template link_simple_callable[][link callable_traits.concepts.ref_simple_callable [concept_simple_callable]]]
[template link_simple_invokable[][link callable_traits.concepts.ref_simple_invokable [concept_simple_invokable]]]
[template link_callable[][link callable_traits.concepts.ref_callable [concept_callable]]]
[template link_invokable[][link callable_traits.concepts.ref_invokable [concept_invokable]]]
[template link_bind_expression[][link callable_traits.concepts.ref_bind_expression [concept_bind_expression]]]
[template link_signature[][link callable_traits.concepts.ref_signature [concept_signature]]]
[template link_constexpr_constructible[][link callable_traits.concepts.ref_constexpr_constructible [concept_constexpr_constructible]]]
[template link_cc_tag[][link callable_traits.concepts.ref_cc_tag [concept_cc_tag]]]

[/ *** reference links *** ]
[template link_add_calling_convention[][link callable_traits.ref_add_calling_convention [^add_calling_convention]]]
[template link_add_function_const[][link callable_traits.ref_add_function_const [^add_function_const]]]
[template link_add_function_cv[][link callable_traits.ref_add_function_cv [^add_function_cv]]]
[template link_add_function_lvalue[][link callable_traits.ref_add_function_lvalue [^add_function_lvalue]]]
[template link_add_function_rvalue[][link callable_traits.ref_add_function_rvalue [^add_function_rvalue]]]
[template link_add_varargs[][link callable_traits.ref_add_varargs [^add_varargs]]]
[template link_add_function_volatile[][link callable_traits.ref_add_function_volatile [^add_function_volatile]]]
[template link_apply_member_pointer[][link callable_traits.ref_apply_member_pointer [^apply_member_pointer]]]
[template link_apply_return[][link callable_traits.ref_apply_return [^apply_return]]]
[template link_arg_at[][link callable_traits.ref_arg_at [^arg_at]]]
[template link_args[][link callable_traits.ref_args [^args]]]
[template link_arity[][link callable_traits.ref_arity [^arity]]]
[template link_bind[][link callable_traits.ref_bind [^bind]]]
[template link_can_invoke[][link callable_traits.ref_can_invoke [^can_invoke]]]
[template link_can_invoke_constexpr[][link callable_traits.ref_can_invoke_constexpr [^can_invoke_constexpr]]]
[template link_function_type[][link callable_traits.ref_function_type [^function_type]]]
[template link_has_calling_convention[][link callable_traits.ref_has_calling_convention [^has_calling_convention]]]
[template link_has_varargs[][link callable_traits.ref_has_varargs [^has_varargs]]]
[template link_has_void_return[][link callable_traits.ref_has_void_return [^has_void_return]]]
[template link_is_const_qualified[][link callable_traits.ref_is_const_qualified [^is_const_qualified]]]
[template link_is_constexpr[][link callable_traits.ref_is_constexpr [^is_constexpr]]]
[template link_is_lvalue_qualified[][link callable_traits.ref_is_lvalue_qualified [^is_lvalue_qualified]]]
[template link_is_reference_qualified[][link callable_traits.ref_is_reference_qualified [^is_reference_qualified]]]
[template link_is_rvalue_qualified[][link callable_traits.ref_is_rvalue_qualified [^is_rvalue_qualified]]]
[template link_is_qualified[][link callable_traits.ref_is_qualified [^is_qualified]]]
[template link_is_volatile_qualified[][link callable_traits.ref_is_volatile_qualified [^is_volatile_qualified]]]
[template link_max_arity[][link callable_traits.ref_max_arity [^max_arity]]]
[template link_min_arity[][link callable_traits.ref_min_arity [^min_arity]]]
[template link_qualified_function_type[][link callable_traits.ref_qualified_function_type [^qualified_function_type]]]
[template link_remove_calling_convention[][link callable_traits.ref_remove_calling_convention [^remove_calling_convention]]]
[template link_remove_function_const[][link callable_traits.ref_remove_function_const [^remove_function_const]]]
[template link_remove_function_cv[][link callable_traits.ref_remove_function_cv [^remove_function_cv]]]
[template link_remove_member_pointer[][link callable_traits.ref_remove_member_pointer [^remove_member_pointer]]]
[template link_remove_function_reference[][link callable_traits.ref_remove_function_reference [^remove_function_reference]]]
[template link_remove_varargs[][link callable_traits.ref_remove_varargs [^remove_varargs]]]
[template link_remove_function_volatile[][link callable_traits.ref_remove_function_volatile [^remove_function_volatile]]]
[template link_result_of[][link callable_traits.ref_result_of [^result_of]]]

[template cc_warning_rationale[]
The rationale for classifying the calling convention features as "experimental" is three-fold:

# Calling conventions are, by definition, highly platform-specific.
# The inclusion of a single calling convention effectively doubles the test surface of [libname] ['on every platform].
# The author's current knowledge of calling conventions is admittedly limited.

It is the author's hope that future versions of [libname] will offer a stable, thoroughly-tested, and well-documented implementation of these features. If you have experience in this domain, your [feedback] is ['highly] appreciated.
]

[template cc_warning_full[]
[warning Features for the manipulation and inspection of calling conventions are optional, which must be enabled with macro definitions. The features regarding them are currently classified as ['experimental], and are subject to breaking changes in future versions of [libname].

[cc_warning_rationale]
]
]

[template cc_warning_brief[]
[warning Features for calling conventions are currently classified as ['experimental], and are subject to breaking changes in future versions of [libname].

[cc_warning_rationale]
]
]

[section:introduction Introduction]

[libname] is a cross-platform C++14 library for the inspection, decomposition, and synthesis of C++ callable types. [libname] is header-only, and does not depend on any non-standard headers. [libname] is currently hosted at [repo].

[note [libname] is not a Boost library.]

[section:prereqs Prerequisite Topics]

This documentation will be most beneficial to readers who posess a basic understanding of the following C++ features:

* [@http://en.cppreference.com/w/cpp/language/partial_specialization template specializations]
* [@http://en.cppreference.com/w/cpp/language/sfinae SFINAE]
* [invoke] rules
* function types
* [@http://en.cppreference.com/w/cpp/language/pointer#Pointers_to_functions function pointers]
* [@http://stackoverflow.com/questions/480248/function-references function references]
* [@http://en.cppreference.com/w/cpp/language/pointer#Pointers_to_member_functions pointers to member functions]
* [@http://en.cppreference.com/w/cpp/language/pointer#Pointers_to_data_members pointers to data members]
* [@http://en.cppreference.com/w/cpp/language/operators#Function_call_operator the function call operator, [^operator()]]
* [@https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers universal references] and [@http://stackoverflow.com/questions/13725747/concise-explanation-of-reference-collapsing-rules-requested-1-a-a-2 reference collapsing rules]
* [@http://en.cppreference.com/w/cpp/language/member_functions#const-.2C_volatile-.2C_and_ref-qualified_member_functions cv-qualified and ref-qualified member functions]
* [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html "abominable" function types]
* [@http://en.cppreference.com/w/cpp/language/overloaded_address taking the address of overloaded functions]
* [@http://en.cppreference.com/w/c/language/variadic C-style variadics], a.k.a. varargs
* [@https://en.wikipedia.org/wiki/X86_calling_conventions calling conventions]
* [@http://en.cppreference.com/w/cpp/utility/functional/bind std::bind expressions] with [@http://en.cppreference.com/w/cpp/utility/functional/placeholders std::placeholders]

[endsect][/section:prereqs]

[section:motivation Motivation]

Consider for a moment the class template below, which defines all [role red[*48]] template specializations necessary to account for all valid function types and member function pointer types in C++11 and C++14:

[import ./hideous_template.snippet.cpp]
[hideous_template]

[note The upcoming ISO standard for C++17 includes a [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0012r1.html change to the core language] which adds the [^noexcept] qualifier to the type system. If the author's understanding is correct, this would increase the the count of necessary template specializations to [role red[*96]] ([feedback]?). Currently, C++17 `noexcept` qualifiers are not handled in [libname], because compiler vendors have not implemented support for this feature (to best of the author's knowledge). However, features to account for and manipulate `noexcept` qualifiers are planned in [libname], as soon as feature is implemented by a compiler vendor. Of course, the [libname] feature additions will be non-breaking for currently supported compiler versions.]

Use cases for such obscure specializations are vitually nonexistent in run-of-the-mill application codebases. Even in library code, these are exceedingly rare. However, there are a handful of very specific metaprogramming scenarios that can only be solved with such template "spam". While these use cases are indeed rare, the writing and testing of these templates is incredibly tedious and time consuming. On this premise, [libname] offers a final and decisive library-level solution, so that authors of generic code will *never again* need to write these specializations, for ['any] reason.

Template specializations like those in the code snippet above ['still] do not account for function pointers, function references, function objects/lambdas, or calling conventions. [libname] goes the extra mile by accounting for all of them.

[cc_warning_full]

The use cases for [libname] are closely related to those of [@http://www.boost.org/doc/libs/1_60_0/libs/type_traits/doc/html/boost_typetraits/reference/function_traits.html function_traits] and [@http://www.boost.org/doc/libs/1_60_0/libs/function_types/doc/html/index.html Boost.FunctionTypes].

[endsect][/section:motivation]

[section:quick_example Quick Example]
[import ../example/intro.cpp]
[intro]
[endsect][/section:quick_example]

[section:reasons What makes [libname] unique?]

[*1.] [libname] offers template aliases such as [link_remove_function_const] for manipulating function qualifiers, designed to parallel the `<type_traits>` aliases such as `std::remove_const_t`.

[*2.] [libname] is designed to accept cv-qualified and ref-qualified types, which eliminates the need to prepare template argument types with metafunctions such as `std::remove_reference` and `std::decay`. This is especially useful when dealing with perfectly-forwarded parameter types in function templates.

[*3.] [libname] is designed to comply with [invoke] rules, with one unobtrusive and beneficial deviation: [link_fn] types types are compatible with all relevant type operations that do not specifically require an invocation.

[*4.] [namespace_scoped][link_arg_at]`<2, Callable>` is more flexible than `typename boost::function_traits<Callable>::arg3_type`.

[*5.] [link_can_invoke] is used to test `INVOKE`-ability at compile-time, with value semantics. For the craziest metaprogrammers, [link_can_invoke_constexpr] does the same as `can_invoke` for [link_constexpr_constructible] types, with an added check for `constexpr`-ness

[*6.] [link_is_constexpr] is used to check whether a [link_constexpr_constructible] type is a [link_callable] type that yields a `constexpr` result -- no arguments necessary.

[*7.] [link_bind] is used to intercept the signature information from a `std::placeholder` expression before forwarding on to `std::bind` or `boost::bind`. This gives library writers the power to create more flexible template APIs for callable types.

[*8.] [link_min_arity] can be used to detect the presence of default arguments on a [link_simple_fn_obj]

[*9.] The [libname] interface mainly consists of template aliases and `constexpr std::integral_constant` functions, which are arguably preferable to `typename foo::type` and `foo::value`. While the `std::integral_constant` functions in [libname] may be a deviation from traditional type trait designs, they facilitate a metaprogramming style that uses value-semantics (a la [hana]). The functions can generally be used with either types or values, which eliminates unnecessary `decltype` usage.

[*10.] [libname] includes optional features for the manipulation and inspection of calling conventions. These features are currently deemed experimental, because they greatly increase the test surface of [libname], are platform-specific, and are not yet fully tested on any platform.

[endsect][/section:reasons]

[endsect][/section:introduction]



[/*********************************************************************]
[/**************** U S E   C A S E   E X A M P L E ********************]
[/*********************************************************************]

[section:function_sugar_example Example: [^ std::function] sugar]

At a glance, there appear to be around 260 [@http://stackoverflow.com/search?q=convert+std%3A%3Abind+to+std%3A%3Afunction search results] on Stack Overflow concerning the conversion from `std::bind` results to `std::function`, and around 340 [@http://stackoverflow.com/search?q=convert+lambda+to+std%3A%3Afunction search results] concerning the conversion of lambdas to `std::function`. There are few good reasons for converting `std::bind` result objects into `std::function` objects, and fewer still for creating `std::function` objects without explicitly specifying the function type. Regardless, here's a `make_function` function, which can...

# Construct an `std::function<T>` where T is not explicitly supplied by the user
# Construct an `std::function<T>` where T is the implied "signature" of an `std::placeholders` expression

`make_function` is rather silly, especially since we have no contextual reason for incurring the costs of type erasure. Still, it's a lightweight example of the kind of metaprogramming you can do with [libname].

[note Due to limitations in the Microsoft compiler, this example will not compile with MSVC. For more information, refer to the [link_msvc_issues] section.]

[import ../example/make_function.cpp]
[make_function]

[endsect][/section:function_sugar_example]



[/*********************************************************************]
[/******************* C O M P A T I B I L I T Y ***********************]
[/*********************************************************************]

[section:compatibility Compatibility]

[libname] is currently tested and working on the following platforms, unless otherwise noted:

[table Supported Platforms
    [[Operating System] [Compilers]]
    [
        [Linux]
        [
            - Clang 3.5 and later (both libc++ and libstdc++)

            - GCC 5.2 and later
        ]
    ]

    [
        [OSX]
        [
            - Apple Clang in Xcode 6.3 and later

            - open-source Clang 3.5 and later should work, but is not yet tested
        ]
    ]

    [
        [Windows]
        [
            - Microsoft Visual Studio 2015 - Clang-cl

            - Microsoft Visual Studio 2015 - native MSVC - partial support (see below)

            - MinGW GCC 5.3 (other versions not tested)
        ]
    ]
]

[template msvc_disabled_functions[]


* [link_bind]
]

See the most recent cross-platform integration test results [@https://travis-ci.org/badair/callable_traits here] at Travis CI. Currently, Travis CI does not support Windows -- all Windows testing is performed locally on the author's Windows 10 machine.

CallableTraits has not been tested on every platform under the sun. If you find CallableTraits to work with another toolchain, [link callable_traits.contact let us know!]

[section:msvc_issues MSVC Issues]

While most of the features in [libname] are tested and working in MSVC, the following 3 functions do not work:

* [link_is_constexpr] - always returns an instance of `std::false_type` in MSVC
* [link_can_invoke_constexpr] - always returns an instance of `std::false_type` in MSVC
* [link_bind] - a static_assert will fail when this function is used in MSVC

[endsect][/section:msvc_issues]

[endsect][/section:compatibility]



[/*********************************************************************]
[/*********************** C O N C E P T S *****************************]
[/*********************************************************************]

[section:concepts Concepts]

[libname] relies on the following concepts, which will be cross-referenced throughout the documentation. Concepts will always be formatted with [role green green] text.

[section:ref_fn_ptr [concept_fn_ptr]]
* Any function pointer type
* the pointer may be cv-qualified and/or ref-qualified
* e.g. `void(*)(int, int)` or `void(* const &)(int, int)`

[endsect]

[section:ref_fn_ref [concept_fn_ref]]
* Any function reference type
* e.g. `void(&)(int, int)`

[endsect]

[section:ref_simple_fn [concept_simple_fn]]
* Any unqualified function type
* Mutually exclusive with [link_abominable]
* e.g. `void(int, int)`

[endsect]

[section:ref_abominable [concept_abominable]]
* Any qualified (a.k.a. [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html "abominable"]) function type
* Not technically "callable", but still falls under the [libname] umbrella
* Mutually exclusive with [link_simple_fn]
* e.g. `void(int, int) const`

[endsect]

[section:ref_fn [concept_fn]]
* The superset of [link_simple_fn] and [link_abominable]

[endsect]

[section:ref_pmf [concept_pmf]]
* Any pointer to member function type
* The pointer type may be cv-qualified and/or ref-qualified
* e.g. `void (foo::*)(int, int)`

[endsect]

[section:ref_pmd [concept_pmd]]
* Any pointer to data member type
* The pointer type may be cv-qualified and/or ref-qualified
* e.g. `int foo::*`

[endsect]

[section:ref_member_ptr [concept_member_ptr]]
* The superset of [link_pmf] and [link_pmd]

[endsect]

[section:ref_simple_fn_obj [concept_simple_fn_obj]]
* Any class/struct with a ['non-templated, non-overloaded] function call operator
* Includes non-generic lambda types
* May be cv-qualified and/or ref-qualified
* Mutually exclusive with [link_overloaded_fn_obj]
* e.g. the type of this lambda: `[](int x, int y) { return x + y; }`

[endsect]

[section:ref_overloaded_fn_obj [concept_overloaded_fn_obj]]
* Any class/struct with a ['templated or overloaded] function call operator, with the following limitation for those with templated function call operators (which includes generic lambdas):
  * If templated , all instantiations must be [@http://stackoverflow.com/questions/35033306/what-does-it-mean-when-one-says-something-is-sfinae-friendly SFINAE-friendly], and must not use [@http://en.cppreference.com/w/cpp/language/indent_name dependent names], except where the dependent "names" are C++ operators.
* May be cv-qualified and/or ref-qualified
* Mutually exclusive with [link_simple_fn_obj]
* e.g. the type of this generic lambda: `[](auto x, auto y) { return x + y; }`

[tip Generic lambdas or classes with templated function objects that are either not SFINAE-friendly or rely on dependent names for template instantiations are generally incompatible with [libname].]

[endsect]

[section:ref_fn_obj [concept_fn_obj]]
* The superset of [link_overloaded_fn_obj] and [link_simple_fn_obj]

[endsect]

[section:ref_signature [concept_signature]]
* The superset of the following:
  * [link_fn_ptr]
  * [link_fn_ref]
  * [link_fn]
  * [link_pmf]

[endsect]

[section:ref_callable [concept_callable]]
* The superset of the following:
  * [link_fn_ptr]
  * [link_fn_ref]
  * [link_fn]
  * [link_pmf]
  * [link_pmd]
  * [link_fn_obj]

[endsect]
  
[section:ref_simple_callable [concept_simple_callable]]
* Includes all [link_callable] types, [*except] [link_overloaded_fn_obj]

[endsect]

[section:ref_simple_invokable [concept_simple_invokable]]
* Includes all [link_callable] types, [*except] [link_overloaded_fn_obj] and [link_fn]

[endsect]

[section:ref_invokable [concept_invokable]]
* Includes all [link_callable] types, [*except] [link_fn]

[endsect]

[section:ref_bind_expression [concept_bind_expression]]
* The return type of a call to [namespace_scoped]`bind`

[endsect]

[section:ref_constexpr_constructible [concept_constexpr_constructible]]
* Any [@http://en.cppreference.com/w/cpp/concept/LiteralType LiteralType] that is also default-constructible

[endsect]

[section:ref_cc_tag [concept_cc_tag]]
* One of the following types, used to manipulate calling conventions programmatically:
  *[namespace_scoped]`cdecl_tag`
  *[namespace_scoped]`stdcall_tag`
  *[namespace_scoped]`fastcall_tag`
  *[namespace_scoped]`pascal_tag`

[endsect]

[endsect][/section:concepts]




[/*********************************************************************]
[/************************ H E A D E R S ******************************]
[/*********************************************************************]

[section:headers Headers]
The simplest way to use [libname] is to include the main header file:

[include_header callable_traits]

[libname] interface is also broken down by trait into individual header files. To use only the traits you need, include one or more of the following headers, listed alphabetically:

* [include_header [link_add_calling_convention]]
* [include_header [link_add_function_const]]
* [include_header [link_add_function_cv]]
* [include_header [link_add_function_lvalue]]
* [include_header [link_add_function_rvalue]]
* [include_header [link_add_varargs]]
* [include_header [link_add_function_volatile]]
* [include_header [link_apply_member_pointer]]
* [include_header [link_apply_return]]
* [include_header [link_arg_at]]
* [include_header [link_args]]
* [include_header [link_arity]]
* [include_header [link_bind]]
* [include_header [link_can_invoke]]
* [include_header [link_can_invoke_constexpr]]
* [include_header [link_function_type]]
* [include_header [link_has_calling_convention]]
* [include_header [link_has_varargs]]
* [include_header [link_has_void_return]]
* [include_header [link_is_const_qualified]]
* [include_header [link_is_constexpr]]
* [include_header [link_is_lvalue_qualified]]
* [include_header [link_is_reference_qualified]]
* [include_header [link_is_rvalue_qualified]]
* [include_header [link_is_qualified]]
* [include_header [link_is_volatile_qualified]]
* [include_header [link_max_arity]]
* [include_header [link_min_arity]]
* [include_header [link_qualified_function_type]]
* [include_header [link_remove_calling_convention]]
* [include_header [link_remove_function_const]]
* [include_header [link_remove_function_cv]]
* [include_header [link_remove_member_pointer]]
* [include_header [link_remove_function_reference]]
* [include_header [link_remove_varargs]]
* [include_header [link_remove_function_volatile]]
* [include_header [link_result_of]]

[endsect][/section:headers]


[template msvc_incompatible[] is not compatible with the Microsoft Visual C++ compiler in Visual Studio (a.k.a. MSVC). Accordingly, the example(s) below will not compile in MSVC. However, Visual Studio users can still use Clang-cl. Refer to the [link_msvc_issues] section for more information.]




[section:ref_add_calling_convention add_calling_convention]

[warning This feature is currently considered experimental. Your [feedback] is much appreciated! ]

    namespace ``[lib_namespace]`` {
	
	    template<typename T, typename CcTag>
		using add_calling_convention = /* implementation-defined */;
		
	}

[heading Constraints]
* `T` must be a [link_fn_ptr] or [link_pmf]
* `CcTag` must be a [link_cc_tag]

[heading Behavior]
Adds the calling convention specified by `CcTag` to the pointer type `T`.

[heading Notes]

For `add_calling_convention` to work as-intended, you must:

# Be programming on a platform that supports adding the desired calling convention to type `T`
# Define one or more of the following macros before including any [libname] headers:
 * `CALLABLE_TRAITS_ENABLE_CDECL` for `__cdecl`
 * `CALLABLE_TRAITS_ENABLE_STDCALL` for `__stdcall`
 * `CALLABLE_TRAITS_ENABLE_FASTCALL` for `__fastcall`
 * `CALLABLE_TRAITS_ENABLE_PASCAL` for `pascal`

[heading Example - [^__fastcall] to [^__stdcall]]
[import ../example/experimental_changing_calling_conventions.cpp]
[experimental_changing_calling_conventions]
[heading Example - [^__cdecl]]
[import ../example/experimental_calling_convention_cdecl.cpp]
[experimental_calling_convention_cdecl]

[heading See Also]
* [link_remove_calling_convention]
* [link_has_calling_convention]

[endsect][/section:ref_add_calling_convention]





[section:ref_add_function_const add_function_const]
    
    namespace ``[lib_namespace]`` {
	
	    template<typename T>
		using add_function_const = /* implementation-defined */;
		
	}
	
[heading Constraints]
`T` must be a [link_fn] or [link_pmf].

[heading Behavior]
* Adds a `const` qualifier to the signature of `T` (if not already present), preserving any pointer qualifiers, such that:
  * `add_function_const<int()>` aliases `int() const`
  * `add_function_const<int(foo::*)() volatile>` aliases `int(foo::*)() const volatile`
  * `add_function_const<int(foo::* const &)()>` aliases `int(foo::* const &)() const`

[heading Example]
[import ../example/add_function_const.cpp]
[add_function_const]

[heading See Also]
* [link_remove_function_const]
* [link_is_const_qualified]

[endsect][/section:ref_add_function_const]





[section:ref_add_function_cv add_function_cv]

    namespace ``[lib_namespace]`` {
	
	    template<typename T>
		using add_function_cv = /* implementation-defined */;
		
	}
	
[heading Constraints]
`T` must be a [link_fn] or [link_pmf].

[heading Behavior]
* Adds both `const` and `volatile` qualifiers to the signature of `T` (if not already present), preserving any pointer qualifiers, such that:
  * `add_function_cv<int()>` aliases `int() const volatile`
  * `add_function_cv<int(foo::*)() volatile>` aliases `int(foo::*)() const volatile`
  * `add_function_cv<int(foo::* const &)()>` aliases `int(foo::* const &)() const volatile`

[heading Example]
[import ../example/add_function_cv.cpp]
[add_function_cv]

[heading See Also]
* [link_add_function_const]
* [link_add_function_volatile]
* [link_remove_function_cv]
* [link_is_cv_qualified]

[endsect][/section:ref_add_function_cv]





[section:ref_add_function_lvalue add_function_lvalue]

    namespace ``[lib_namespace]`` {
	
	    template<typename T>
		using add_function_lvalue = /* implementation-defined */;
		
	}
	
[heading Constraints]
`T` must be a [link_fn] or [link_pmf].

[heading Behavior]
* Adds an lvalue reference qualifier (`&`) qualifier to the signature of `T` (if not already present)
* If an rvalue reference qualifier is present, the lvalue reference qualifier replaces it (in arbitrary accordance with reference collapsing rules)
* Any pointer qualifiers are preserved
* Such that:
  * `add_function_lvalue<int()>` aliases `int() &`
  * `add_function_lvalue<int(foo::*)() const &&>` aliases `int(foo::*)() const &`
  * `add_function_lvalue<int(foo::* const &)()>` aliases `int(foo::* const &)() &`
  
[import ../example/add_function_lvalue.cpp]
[add_function_lvalue]

[heading See Also]
* [link_is_lvalue_qualified]
* [link_add_function_rvalue]
* [link_remove_function_reference]

[endsect][/section:ref_add_function_lvalue]




[section:ref_add_function_rvalue add_function_rvalue]

    namespace ``[lib_namespace]`` {
	
	    template<typename T>
		using add_function_rvalue = /* implementation-defined */;
		
	}
	
[heading Constraints]
`T` must be a [link_fn] or [link_pmf].

[heading Behavior]
* Adds an rvalue reference qualifier (`&&`) qualifier to the signature of `T` (if not already present)
* If an lvalue reference qualifier is present, the lvalue reference qualifier remains (in arbitrary accordance with reference collapsing rules)
* Any pointer qualifiers are preserved
* Such that:
  * `add_function_rvalue<int()>` aliases `int() &&`
  * `add_function_rvalue<int(foo::*)() const &>` aliases `int(foo::*)() const &`
  * `add_function_rvalue<int(foo::* const &)()>` aliases `int(foo::* const &)() &&`
  
[heading Example]
[import ../example/add_function_rvalue.cpp]
[add_function_rvalue]

[heading See Also]
* [link_add_function_lvalue]
* [link_remove_function_reference]

[endsect][/section:ref_add_function_rvalue]





[section:ref_add_varargs add_varargs]

    namespace ``[lib_namespace]`` {
	
	    template<typename T>
		using add_varargs = /* implementation-defined */;
		
	}
	
[heading Constraints]

`T` must be one of the following:

* [link_fn]
* [link_fn_ptr]
* [link_fn_ref]
* [link_pmf]

[heading Behavior]
* Adds C-style variadics (`...`) to the signature of `T` (if not already present), preserving any pointer qualifiers, such that:
  * `add_varargs<int()>` aliases `int(...)`
  * `add_varargs<int(* const)()>` aliases `int(* const)(int, ...)`
  * `add_varargs<int(&)()>` aliases `int(&)(int, ...)`
  * `add_varargs<int(foo::* volatile &)() const>` aliases `int(foo::* volatile &)(...) const`
	
[heading Example]
[import ../example/add_varargs.cpp]
[add_varargs]

[heading See Also]
* [link_remove_varargs]
* [link_has_varargs]
* [link_remove_function_reference]

[endsect][/section:ref_add_varargs]





[section:ref_add_function_volatile add_function_volatile]

    namespace ``[lib_namespace]`` {
	
	    template<typename T>
		using add_function_volatile = /* implementation-defined */;
		
	}
	
[heading Constraints]
`T` must be a [link_fn] or [link_pmf].

[heading Behavior]
* Adds a `volatile` qualifier to the signature of `T` (if not already present), preserving any pointer qualifiers, such that:
  * `add_function_volatile<int()>` aliases `int() volatile`
  * `add_function_volatile<int(foo::*)() const>` aliases `int(foo::*)() const volatile`
  * `add_function_volatile<int(foo::* const &)()>` aliases `int(foo::* const &)() volatile`

[heading Example]
[import ../example/add_function_volatile.cpp]
[add_function_volatile]

[heading See Also]
* [link_remove_function_volatile]
* [link_is_volatile_qualified]

[endsect][/section:ref_add_function_volatile]




[section:ref_apply_member_pointer apply_member_pointer]

    namespace ``[lib_namespace]`` {
	
	    template<typename T, typename Class>
		using apply_member_pointer = /* implementation-defined */;
		
	}
	
[heading Constraints]

`T` must be one of the following:

* [link_fn]
* [link_fn_ptr]
* [link_fn_ref]
* [link_member_ptr]

[heading Behavior]
* When the constraints are violated, a substitution failure occurs.
* Otherwise, when `T` is a [link_fn], [link_fn_ptr], or [link_fn_ref]:
  * Let `Args...` represent the parameter types in the signature of `T`
  * Let `Return` represent the return type of `T`
  * `apply_member_pointer<T, Class>` aliases `Return(Class::* /* any pointer qualifiers on T */ )(Args...)`
* Otherwise, when `T` is a [link_member_ptr],
  * Let `CurrentClass` represent the parent class of `T`
  * Let `MemberType` represent the type pointed to by `T`, such that `std::is_same<MemberType CurrentClass::*, std::decay_t<T>>::value` is true
  * `apply_member_pointer<T, Class>` aliases `MemberType Class::* /* any pointer qualifiers on T */`

[heading Example]
[import ../example/apply_member_pointer.cpp]
[apply_member_pointer]

[heading See Also]
* [link_remove_member_pointer]

[endsect][/section:ref_apply_member_pointer]





[section:ref_apply_return apply_return]

    namespace ``[lib_namespace]`` {
	
	    template<typename T, typename Return>
		using apply_return = /* implementation-defined */;
		
	}
	
[heading Constraints]

`T` must be a [link_signature] or a [link_pmd].

[heading Behavior]
* When `T` is a [link_signature], the aliased type will be identical to `T`, except that the aliased type will now return `Return`, such that:
  * `apply_return<void(), int>` aliases `int()`
  * `apply_return<int(* const)(char), const char*>` aliases `const char*(* const)(char)`
  * `apply_return<int(&)(), void>` aliases `void(&)()`
  * `apply_return<int(foo::*&)() const volatile &&, short>` aliases `short(foo::*&)() const volatile &&`
* When `T` is a [link_pmd],
  * Let `Class` represent the parent class of `T`
  * the aliased type is `Return Class::* /* any qualifiers on T */`, such that:
  * `apply_return<int foo::* const &, char>` becomes `char foo::* const &`

[heading Example]
[/import ../example/apply_return.cpp]
[apply_return]

[endsect][/section:ref_apply_return]




[section:ref_arg_at arg_at]

    namespace ``[lib_namespace]`` {
	
	    template<std::size_t Index, typename T>
		using arg_at = /* implementation-defined */;
		
	}
	
[heading Constraints]
* `T` must be one of the following:
  * [link_signature]
  * [link_simple_fn_obj]
  * [link_bind_expression]
* When `T` is a [link_signature], then:
  * Let `ArgCount` represent the number of arguments in the signature of `T`
  * `Index` must be less than `ArgCount` and greater than zero
* Otherwise, when `T` is a [link_simple_fn_obj], then:
  * Let `ArgCount` represent the number of arguments in `decltype(&std::decay_t<T>::operator())`
  * `Index` must be less than `ArgCount` and greater than zero
* Otherwise, when `T` is a [link_bind_expression], then:
  * Let `MaxPlaceholder` represent the type of the largest `std::placeholders` object in the bind expression tree
  * `Index` must be less than `std::is_placeholder<MaxPlaceholder>::value` and greater than zero
  
[heading Behavior]
* If any constraints are violated, a substitution failure occurs
* Otherwise, `arg_at<Index, T>` aliases `std::tuple_element_t<Index, `[namespace_scoped][link_args]`<T>>`, such that:
  * `arg_at<0, void(char, short, long, int*)>` aliases `char`
  * `arg_at<1, void(* volatile)(char, short, long, int*)>` aliases `short`
  * `arg_at<2, void(&)(char, short, long, int*)>` aliases `long`
  * `arg_at<3, void(foo::* const &)(char, short, long, int*)>` aliases `int*`
  
[heading Example]
[/import ../example/arg_at.cpp]
[arg_at]

[heading See Also]
* [link_args]

[endsect][/section:ref_arg_at]





[section:ref_args args]

    namespace ``[lib_namespace]`` {
	
	    template<typename T>
		using args = /* implementation-defined */;
		
	}
	
[heading Constraints]
`T` must be one of the following:
* [link_signature]
* [link_simple_fn_obj]
* [link_bind_expression]

[heading Behavior]
* When the constraints are violated, a substitution failure occurs
* Otherwise, when `T` is a [link_signature], then:
  * Let `Args...` represent the parameter types in the signature of `T`
  * `args<T>` aliases `std::tuple<Args...>`
* Otherwise, when `T` is a [link_simple_fn_obj], then:
  * Let `Args...` represent the parameter types in the signature of `decltype(&std::decay_t<T>::operator())`
  * `args<T>` aliases `std::tuple<Args...>`
* Otherwise, when `T` is a [link_bind_expression], then:
  * Let `bind_args...` represent the argument values that were passed to [namespace]`bind` which returned an instance of `T`
  * Let `bind_result` represent the return value of `std::bind(bind_args...)`
  * Let `Args...` represent the "valid argument types" to `bind_result`'s `operator()`
    * Note: the "valid argument types" are implied by the position of the `std::placeholders` objects
  * `args<T>` aliases `std::tuple<Args...>`

[heading Example]
[import ../example/args.cpp]
[args]

[heading See Also]
* [link_arg_at]

[endsect][/secttion:ref_args]




[section:ref_arity arity]

    namespace ``[lib_namespace]`` {
	
		template<typename T>
		inline constexpr auto arity() {
		   /* implementation defined */
		}
		
	    template<typename U>
		inline constexpr auto arity(U&&) {
			return arity<U&&>();
		}
	}
	
[heading Constraints]
`T` must be a [link_signature] or a [link_simple_fn_obj].

[heading Behavior]
* When the constraints are violated, an instance of type `std::integral_constant<int, -1>` is returned.
* Otherwise, when `T` is a [link_signature]
  * let `ArgCount` represent the number of parameter types in the signature of `T`
  * `arity<T>()` returns an instance of type `std::integral_constant<int, ArgCount>`
* Otherwise, when `T` is a [link_simple_fn_obj]
  * Let `ArgCount` represent the number of parameter types in the signature of `decltype(&std::decay_t<T>::operator())`
  * `arity<T>()` returns an instance of type `std::integral_constant<int, ArgCount>`

[heading Example]
[/import ../example/arity.cpp]
[arity]
[endsect]

[section:ref_bind bind]

[note [namespace_scoped]`bind` [msvc_incompatible]]

    namespace ``[lib_namespace]`` {
	
		template<typename... Ts>
		inline ``[^[link_bind_expression]]`` bind(Ts&&... ts);
		
	}
	
[namespace_scoped]`bind` is used to parse type information from potentially complex `std::placeholders` expressions. The type information in [namespace_scoped]`bind` cannot legally/portably be extracted from `std::bind`, because `std::bind`'s implementation is opaque.

[heading Constraints]
* The arguments to [namespace_scoped]`bind` must be legal arguments to `std::bind`, substituting `std::bind` for [namespace_scoped]`bind` in nested sub-expressions where necessary to meet this constraint
* All nested sub-expressions must be a call to [namespace_scoped]`bind` instead of `std::bind`
* If a call to [namespace_scoped]`bind` passes an [link_overloaded_fn_obj] instance as its first argument, then:
  * any placeholder objects passed in this call must be re-used somewhere else in the expression tree, bing passed in another call to [namespace_scoped]`bind` where a [link_simple_callable] as its first argument (otherwise, no inference could be made about the parameter type being "place-held")

[heading Behavior]
* If any constraints are violated, the result is undefined
* The return type of [namespace_scoped]`bind` can be passed to any of the following:
  * [namespace_scoped][^[link_args]]
  * [namespace_scoped][^[link_arg_at]]
  * [namespace_scoped][^[function_type]]
  * [namespace_scoped][^[result_of]]
* For convenience, the object returned by [namespace_scoped]`bind` serves as a wrapper around `std::bind`, forwarding from its `operator()` to a private member object constructed from `std::bind` in the original [namespace_scoped]`bind`

[heading Notes]
* [namespace_scoped]`bind` is the only feature of [libname] with non-constexpr behavior. However, the runtime behavior is only provided for convenience -- [namespace_scoped]`bind` is designed to be a metaprogramming tool, and may be used in unevaluated contexts.
[heading Example 1]
[import ../example/bind_1.cpp]
[bind_1]
[heading Example 2]
[import ../example/bind_2.cpp]
[bind_2]

[heading See Also]
  * [link_args]
  * [link_arg_at]
  * [function_type]
  * [result_of]
  
[endsect]

[section:ref_can_invoke can_invoke]

    namespace ``[lib_namespace]`` {
	
		template<typename T, typename... Args>
		inline constexpr auto can_invoke(T&&, Args&&...);
		
	}

[heading Constraints]
* When `std::decay_t<T>` is a class/struct with a templated `operator()`, it's invocation must be SFINAE-friendly with respect to `Args&&...`
* No other constraints

[heading Behavior]
* If all arguments to `can_invoke` can legally be forwarded to [invoke], then an instance of `std::true_type` is returned
* Otherwise, an instance of `std::false_type` is returned

[heading Example - Function Object]
[import ../example/can_invoke_function_object.cpp]
[can_invoke_function_object]
[heading Example - Member Function Pointer]
[import ../example/can_invoke_member_function_pointer.cpp]
[can_invoke_member_function_pointer]
[heading Example - Function Pointer]
[import ../example/can_invoke_function_pointer.cpp]
[can_invoke_function_pointer]
[heading Example - Function Reference]
[import ../example/can_invoke_function_reference.cpp]
[can_invoke_function_reference]

[heading See Also]
* [link_can_invoke_constexpr]

[endsect]




[section:ref_can_invoke_constexpr can_invoke_constexpr]

[note `can_invoke_constexpr` [msvc_incompatible]]

    namespace ``[lib_namespace]`` {
	
		template<typename T, typename... Args>
		inline constexpr auto can_invoke_constexpr(T&& t, Args&&... args);
		
	}

[heading Constraints]
* None, except when `std::decay_t<T>` is a class/struct with a templated `operator()`, it's invocation must be SFINAE-friendly with respect to `Args...`

[heading Behavior]
* An instance of `std::false_type` is returned, except when:
  * arguments to `can_invoke_constexpr` can legally be forwarded to [invoke], *and*
  * `std::decay_t<T>` is [link_constexpr_constructible], *and*
  * `std::decay_t<Args>...` are also all [link_constexpr_constructible], *and*
  * an invocation of the arguments following [invoke] semantics is a constant expression, then:
    * an instance of `std::true_type` is returned

[heading Example - Function Object]
[import ../example/can_invoke_constexpr_function_object.cpp]
[can_invoke_constexpr_function_object]
[heading Example - Member Function Pointer]
[import ../example/can_invoke_constexpr_member_function_pointer.cpp]
[can_invoke_constexpr_member_function_pointer]
[heading Example - Function Pointer]
[import ../example/can_invoke_constexpr_function_pointer.cpp]
[can_invoke_constexpr_function_pointer]

[heading See Also]
* [link_can_invoke]
* [link_is_constexpr]

[endsect]





[section:ref_function_type function_type]

    namespace ``[lib_namespace]`` {
	
	    template<typename T>
		using function_type = /* implementation-defined */;
	}
		
[heading Constraints]
`T` must be a [link_simple_callable].

[heading Behavior]

`function_type` is used to "decay" a [link_simple_callable] into an [invoke]-aware [link_simple_fn].

* When the constraints are violated, the substitution fails in a SFINAE-friendly manner.
* Otherwise, when `T` is a [link_pmf], then:
  * Let `Args...` represent the parameter types in the signature of `T`
  * Let `ClassRef` represent a reference of the parent class/struct of `T`, applying any qualifiers necessary to match the member function qualifiers on `T`
  * Let `Return` represent the return type of `T`
  * `function_type<T>` aliases `Return(ClassRef, Args...)`
  * such that:
    * `function_type<int(foo::*)(char)>` aliases `int(foo &, char)`
    * `function_type<int(foo::*)(char) &&>` aliases `int(foo &&, char)`
	* `function_type<int(foo::*)(char) const>` aliases `int(foo const &, char)`
* Otherwise, when `T` is a [link_pmd], then:
  * Let `ClassRef` represent a `const` reference of the parent class/struct of `T`
  * Let `Return` represent the pointed-to data member type of `T`
  * `function_type<T>` aliases `Return(ClassRef)`
  * such that:
    * `function_type<int foo::*>` aliases `int(foo const &)`
	* `function_type<int foo::* const &>` also aliases `int(foo const &)`
* Otherwise, when `T` is a [link_signature]:
  * Let `Args...` represent the parameter types in the signature of `T`
  * Let `Return` represent the return type of `T`
  * `function_type<T>` aliases `Return(Args...)`
*Otherwise, when `T` is a [link_simple_fn_obj], then:
  * Let `Args...` represent the parameter types in the signature of `decltype(&std::decay_t<T>::operator())`
  * Let `Return` represent the return type of `decltype(&std::decay_t<T>::operator())`
  * `function_type<T>` aliases `Return(Args...)`
*Otherwise, when `T` is a [link_bind_expression], then:
  * Let `std::tuple<Args...>` represent [namespace_scoped][^[link_args]]`<T>`
  * Let `bind_args...` represent the argument values that were passed to [namespace]`bind` which returned an instance of `T`
  * Let `bind_result` represent the return value of `std::bind(bind_args...)`
  * Let `Return` represent `decltype(bind_result(std::declval<Args>()...))`
  * `function_type<T>` aliases `Return(Args...)`
  
[heading Example]
[import ../example/function_type.cpp]
[function_type]

TODO - PMD and PMF examples

[heading See Also]
* [link_args]
* [link_result_of]
* [link_qualified_function_type]

[endsect][/section:ref_function_type]





[section:ref_has_calling_convention has_calling_convention]

    namespace ``[lib_namespace]`` {
	
	    template<typename T, typename CcTag>
		inline constexpr auto has_calling_convention() {
			/* implementation-defined */
		}
		
		template<typename U, typename CcTag>
		inline constexpr auto has_calling_convention(U&&) {
			return has_calling_convention<U, CcTag>();
		}
	}
	
[heading Constraints]
* `T` must be a [link_fn_ptr] or [link_pmf]
* `CcTag` must be a [link_cc_tag]

[heading Behavior]
* If `T` uses the calling convention specified by `CcTag`, then an instance of `std::true_type` is returned.
* Otherwise, an instance of `std::false_type` is returned.

[heading Notes]

For `has_calling_convention` to work as-intended, you must:

# Be programming on a platform that supports the desired calling convention
# Define one or more of the following macros before including any [libname] headers:
 * `CALLABLE_TRAITS_ENABLE_CDECL` for `__cdecl`
 * `CALLABLE_TRAITS_ENABLE_STDCALL` for `__stdcall`
 * `CALLABLE_TRAITS_ENABLE_FASTCALL` for `__fastcall`
 * `CALLABLE_TRAITS_ENABLE_PASCAL` for `pascal`
	
[heading Example - [^__fastcall] to [^__stdcall]]
[experimental_changing_calling_conventions]

[heading See Also]
* [link_add_calling_convention]
* [link_remove_calling_convention]

[endsect]

[section:ref_has_varargs has_varargs]

    namespace ``[lib_namespace]`` {
	
	    template<typename T>
		inline constexpr auto has_varargs() {
			/* implementation-defined */
		}
		
		template<typename U>
		inline constexpr auto has_varargs(U&&) {
			return has_varargs<U&&>();
		}
	}
	
[heading Constraints]
* `T` must be a [link_simple_callable]

[heading Behavior]
* If the constraints are violated, a substitution failure occurs
* Otherwise, if `T` is a [link_signature], then:
  * If `T` uses C-style variadics, an instance of `std::true_type` is returned
  * Otherwise, an instance of `std::false_type` is returned
* Otherwise, if `T` is a [link_simple_fn_obj], then:
  * If `decltype(&std::decay_t<T>::operator())` uses C-style variadics, then an instance of `std::true_type` is returned
  * Otherwise, an instance of `std::false_type` is returned
* Otherwise, an instance of `std::false_type` is returned
  
[heading Example]
[/import ../example/has_varargs.cpp]
[has_varargs]

[heading See Also]
* [link_add_varargs]
* [link_remove_varargs]

[endsect]

[section:ref_has_void_return has_void_return]
TODO
[heading Example]
[/import ../example/has_void_return.cpp]
[has_void_return]
[endsect]

[section:ref_is_const_qualified is_const_qualified]
TODO
[heading Example]
[/import ../example/is_const_qualified.cpp]
[is_const_qualified]
[endsect]

[section:ref_is_constexpr is_constexpr]
TODO
[heading Example - Function Object]
[import ../example/is_constexpr_function_object.cpp]
[is_constexpr_function_object]
[heading Example - Function Pointer]
[import ../example/is_constexpr_function_pointer.cpp]
[is_constexpr_function_pointer]
[endsect]

[section:ref_is_lvalue_qualified is_lvalue_qualified]
TODO
[heading Example]
[/import ../example/is_lvalue_qualified.cpp]
[is_lvalue_qualified]
[endsect]

[section:ref_is_reference_qualified is_reference_qualified]
TODO
[heading Example]
[/import ../example/is_reference_qualified.cpp]
[is_reference_qualified]
[endsect]

[section:ref_is_rvalue_qualified is_rvalue_qualified]
TODO
[heading Example]
[/import ../example/is_rvalue_qualified.cpp]
[is_rvalue_qualified]
[endsect]

[section:ref_is_qualified is_qualified]
TODO
[heading Example]
[/import ../example/is_qualified.cpp]
[is_qualified]
[endsect]

[section:ref_is_volatile_qualified is_volatile_qualified]
TODO
[heading Example]
[/import ../example/is_volatile_qualified.cpp]
[is_volatile_qualified]
[endsect]

[section:ref_max_arity max_arity]
TODO
[heading Example]
[/import ../example/max_arity.cpp]
[max_arity]
[endsect]

[section:ref_min_arity min_arity]
TODO
[heading Example]
[/import ../example/min_arity.cpp]
[min_arity]
[endsect]

[section:ref_qualified_function_type qualified_function_type]
TODO
[heading Example]
[/import ../example/qualified_function_type.cpp]
[qualified_function_type]
[endsect]

[section:ref_remove_calling_convention remove_calling_convention]
TODO
[heading Example - [^__fastcall] to [^__stdcall]]
[experimental_changing_calling_conventions]
[endsect]

[section:ref_remove_function_const remove_function_const]
TODO
[heading Example]
[/import ../example/remove_function_const.cpp]
[remove_function_const]
[endsect]

[section:ref_remove_function_cv remove_function_cv]
TODO
[heading Example]
[/import ../example/remove_function_cv.cpp]
[remove_function_cv]
[endsect]

[section:ref_remove_member_pointer remove_member_pointer]
TODO
[heading Example]
[import ../example/remove_member_pointer.cpp]
[remove_member_pointer]
[endsect]

[section:ref_remove_function_reference remove_function_reference]
TODO
[heading Example]
[/import ../example/remove_function_reference.cpp]
[remove_function_reference]
[endsect]

[section:ref_remove_varargs remove_varargs]
TODO
[heading Example]
[/import ../example/remove_varargs.cpp]
[remove_varargs]
[endsect]

[section:ref_remove_function_volatile remove_function_volatile]
TODO
[heading Example]
[/import ../example/remove_function_volatile.cpp]
[remove_function_volatile]
[endsect]

[section:ref_result_of result_of]
TODO
[heading Example]
[import ../example/result_of.cpp]
[result_of]
[endsect]




[/*********************************************************************]
[/************** A C K N O W L E D G E M E N T S **********************]
[/*********************************************************************]


[section:acknowledgements Acknowledgements]

Special thanks to Louis Dionne, whose massive [hana] project was the original source of inspiration for [libname]. Louis' occasional suggestions have been invaluable throughout the development of [libname].

Robert Ramey's CppCon 2014 presentation [@https://www.youtube.com/watch?v=ACeNgqBKL7E "How you can make a Boost C++ Library"], along with the related material found at the [@http://rrsd.com/blincubator.com/ Boost Library Incubator] have been excellent resources for the development and documentation of [libname].

Finally, I'd like to thank the faculty of the Harding University Computer Science Department for their mentorship and standards of excellence.

[endsect][/section:acknowledgements]



[/*********************************************************************]
[/************************* C O N T A C T *****************************]
[/*********************************************************************]

[section:contact Contact]

[libname] is authored and maintained by Barrett Adair

Comments, feedback, bug reports, and questions are appreciated, which can be submitted in the following ways:

# Open a new issue [@https://github.com/badair/callable_traits/issues/new here] on GitHub
# Message the author [@https://gitter.im/badair/callable_traits here] on Gitter, an excellent chat service built around GitHub, with message persistence and Markdown support
# Send the author an email at
  * barrettellisadair
  * at...
  * gmail dot com
  * (please excuse the anti-spam formatting)

[endsect][/section:contact]


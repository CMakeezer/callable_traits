[article CallableTraits
    [quickbook 1.6]
    [id callable_traits]
        [copyright 2016 Barrett Adair]
    [authors [Adair, Barrett]]
        [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE.md or copy at
        [@http://www.boost.org/LICENSE_1_0.txt http://www.boost.org/LICENSE_1_0.txt])
    ]
    [source-mode c++]
        [last-revision $Date$]
        [lang en]
]

[/ developer: you should enable word wrap before you read further]

[template libname[][^CallableTraits]]
[template libns[][^callable_traits::]]
[template header_include_prefix[]callable_traits/]
[template detail_open_include[]    `#include<`[^[header_include_prefix]]]
[template detail_close_include[]`.hpp>`]
[template include_header[name][detail_open_include][^[name]][detail_close_include]]
[template invoke[][@http://en.cppreference.com/w/cpp/utility/functional/invoke INVOKE]]
[template hana[][@https://boostorg.github.io/hana/ [^Boost.Hana]]]
[template feedback[][link callable_traits.contact feedback]]
[template repo[][@https://github.com/badair/callable_traits GitHub]]

[template cc_warning_rationale[]
The rationale for classifying the calling convention features as "experimental" is three-fold:

# Calling conventions are, by definition, highly platform-specific.
# The inclusion of a single calling convention effectively doubles the test surface of [libname] ['on every platform].
# The author's current knowledge of calling conventions is admittedly limited.

It is the author's hope that future versions of [libname] will offer a stable, thoroughly-tested, and well-documented implementation of these features. If you have experience in this domain, your [feedback] is ['highly] appreciated.
]

[template cc_warning_full[]
[warning Features for the manipulation and inspection of calling conventions are optional, which must be enabled with macro definitions. The features regarding them are currently classified as ['experimental], and are subject to breaking changes in future versions of [libname].

[cc_warning_rationale]
]
]

[template cc_warning_brief[]
[warning Features for calling conventions are currently classified as ['experimental], and are subject to breaking changes in future versions of [libname].

[cc_warning_rationale]
]
]


[/ *** concepts *** ]

[template concept_fn_obj[][role green FunctionObject]]
[template concept_overloaded_fn_obj[][role green OverloadedFunctionObject]]
[template concept_simple_fn_obj[][role green SimpleFunctionObject]]
[template concept_pmf[][role green MemberFunctionPtr]]
[template concept_pmd[][role green MemberDataPtr]]
[template concept_member_ptr[][role green MemberPtr]]
[template concept_fn[][role green Function]]
[template concept_abominable[][role green AbominableFunction]]
[template concept_fn_ptr[][role green FunctionPtr]]
[template concept_fn_ref[][role green FunctionReference]]
[template concept_simple_callable[][role green SimpleCallable]]
[template concept_simple_invokable[][role green SimpleInvokable]]
[template concept_callable[][role green Callable]]
[template concept_invokable[][role green Invokable]]
[template concept_constexpr_constructible[][role green ConstexprDefaultConstructible]]

[/ *** concept links *** ]

[template link_fn_obj[][link ref_fn_obj [concept_fn_obj]]]
[template link_overloaded_fn_obj[][link ref_overloaded_fn_obj [concept_overloaded_fn_obj]]]
[template link_simple_fn_obj[][link ref_simple_fn_obj [concept_simple_fn_obj]]]
[template link_pmf[][link ref_pmf [concept_pmf]]]
[template link_pmd[][link ref_pmd [concept_pmd]]]
[template link_member_ptr[][link ref_member_ptr [concept_member_ptr]]]
[template link_fn[][link ref_fn [concept_fn]]]
[template link_abominable[][link ref_abominable [concept_abominable]]]
[template link_fn_ptr[][link ref_fn_ptr [concept_fn_ptr]]]
[template link_fn_ref[][link ref_fn_ref [concept_fn_ref]]]
[template link_simple_callable[][link ref_simple_callable [[concept_simple_callable]]]]
[template link_simple_invokable[][link ref_simple_invokable [concept_simple_invokable]]]
[template link_callable[][link ref_callable [concept_callable]]]
[template link_invokable[][link ref_invokable [concept_invokable]]]
[template link_constexpr_constructible[][link ref_constexpr_constructible [concept_constexpr_constructible]]]

[section:introduction Introduction]

[libname] provides a comprehensive, uniform, and modern type-level interface for the inspection, decomposition, and synthesis of C++ callable types. This documentation will be most beneficial to readers with a basic understanding of the syntax and usage of the following C++ features:

* [@http://en.cppreference.com/w/cpp/language/partial_specialization template specializations]
* [@http://en.cppreference.com/w/cpp/language/sfinae SFINAE]
* [invoke] rules
* function types
* [@http://en.cppreference.com/w/cpp/language/pointer#Pointers_to_functions function pointers]
* [@http://stackoverflow.com/questions/480248/function-references function references]
* [@http://en.cppreference.com/w/cpp/language/pointer#Pointers_to_member_functions pointers to member functions]
* [@http://en.cppreference.com/w/cpp/language/pointer#Pointers_to_data_members pointers to data members]
* [@http://en.cppreference.com/w/cpp/language/operators#Function_call_operator the function call operator, [^operator()]]
* [@https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers universal references] and [@http://stackoverflow.com/questions/13725747/concise-explanation-of-reference-collapsing-rules-requested-1-a-a-2 reference collapsing rules]
* [@http://en.cppreference.com/w/cpp/language/member_functions#const-.2C_volatile-.2C_and_ref-qualified_member_functions cv-qualified and ref-qualified member functions]
* [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html "abominable" function types]
* [@http://en.cppreference.com/w/cpp/language/overloaded_address taking the address of an overloaded function]
* [@http://en.cppreference.com/w/c/language/variadic C-style variadics], a.k.a. varargs
* [@https://en.wikipedia.org/wiki/X86_calling_conventions calling conventions]

The [libname] development repository is hosted at [repo].

[section:motivation Motivation]

Consider for a moment the class template below, which defines all [role red[*48]] template specializations necessary to account for all valid function types and member function pointer types in C++11 and C++14:

[import ./hideous_template.snippet.cpp]
[hideous_template]

[note The upcoming ISO standard for C++17 includes a [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0012r1.html change to the core language] which adds the [^noexcept] qualifier to the type system. If the author's understanding is correct, this would increase the the count of necessary template specializations to [role red[*96]] ([feedback]?). Currently, C++17 `noexcept` qualifiers are not handled in [libname], because compiler vendors have not implemented support for this feature (to best of the author's knowledge). However, features to account for and manipulate `noexcept` qualifiers are planned in [libname], as soon as feature is implemented by a compiler vendor. Of course, the [libname] feature additions will be non-breaking for currently supported compiler versions.]

Potential use cases for such obscure specializations are vitually nonexistent in run-of-the-mill application codebases. Even in library code, these are exceedingly rare. However, there are a handful of very specific metaprogramming scenarios that can only be solved with such template "spam". While these use cases are indeed rare, the writing and testing of these templates is incredibly tedious and time consuming. On this premise, [libname] offers a final and decisive library-level solution, so that authors of generic code will *never again* need to write these specializations, for ['any] reason.

Template specializations like those in the code snippet above ['still] do not account for function pointers, function references, function objects/lambdas, or calling conventions. [libname] goes the extra mile by accounting for all of them.

[cc_warning_full]

The use cases for [libname] are closely related to those of [@http://www.boost.org/doc/libs/1_60_0/libs/type_traits/doc/html/boost_typetraits/reference/function_traits.html function_traits] and [@http://www.boost.org/doc/libs/1_60_0/libs/function_types/doc/html/index.html Boost.FunctionTypes].

[endsect]

[section Quick Example]
[import ../example/intro.cpp]
[intro]
[endsect]

[section:basic_concepts Concept Definitions]

[libname] relies on the following concepts, and will be referenced throughout this documentation:

[heading:ref_fn_ptr [concept_fn_ptr]]
* Any function pointer type
* the pointer may be cv-qualified and/or ref-qualified
* e.g. `void(*)(int, int)` or `void(* const &)(int, int)`

[heading:ref_fn_ref [concept_fn_ref]]
* Any function reference type
* e.g. `void(&)(int, int)`

[heading:ref_fn [concept_fn]]
* Any unqualified function type
* e.g. `void(int, int)`

[heading:ref_abominable [concept_abominable]]
* Any qualified (a.k.a. [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html "abominable"]) function type
* Not technically "callable", but still falls under the [libname] umbrella
* Mutually exclusive with [link_fn]
* e.g. `void(int, int) const`

[heading:ref_pmf [concept_pmf]]
* Any pointer to member function type
* The pointer type may be cv-qualified and/or ref-qualified
* e.g. `void (foo::*)(int, int)`

[heading:ref_pmd [concept_pmd]]
* Any pointer to data member type
* The pointer type may be cv-qualified and/or ref-qualified
* e.g. `int foo::*`

[heading:ref_simple_fn_obj [concept_simple_fn_obj]]
* Any class/struct with a ['non-templated, non-overloaded] function call operator
* Includes non-generic lambda types
* May be cv-qualified and/or ref-qualified.
* Mutually exclusive with [link_overloaded_fn_obj]
* e.g. the type of this lambda: `[](int x, int y) { return x + y; }`

[heading:ref_overloaded_fn_obj [concept_overloaded_fn_obj]]
* Any class/struct with a ['templated or overloaded] function call operator, with the following limitation for those with templated function call operators (which includes generic lambdas):
  * If templated , all instantiations must be [@http://stackoverflow.com/questions/35033306/what-does-it-mean-when-one-says-something-is-sfinae-friendly SFINAE-friendly], and must not use [@http://en.cppreference.com/w/cpp/language/indent_name dependent names], except where the dependent "names" are C++ operators.
* May be cv-qualified and/or ref-qualified
* e.g. the type of this generic lambda: `[](auto x, auto y) { return x + y; }`

[tip Generic lambdas or classes with templated function objects that are either not SFINAE-friendly or rely on dependent names for template instantiations are generally incompatible with [libname].]

[heading:ref_fn_obj [concept_fn_obj]]
* Any type that is either an [link_overloaded_fn_obj] or a [link_simple_fn_obj]

[heading:ref_callable [concept_callable]]
* The superset of the following:
  * [link_fn_ptr]
  * [link_fn_ref]
  * [link_fn]
  * [link_abominable]
  * [link_pmf]
  * [link_pmd]
  * [link_fn_obj]

[heading:ref_simple_callable [[concept_simple_callable]]]
* Includes all [link_callable] types, [*except] for [link_overloaded_fn_obj]

[heading:ref_simple_invokable [concept_simple_invokable]]
* Includes all [link_callable] types, [*except] for [link_overloaded_fn_obj], [link_fn], and [link_abominable]

[heading:ref_invokable [concept_invokable]]
* Includes all [link_callable] types, [*except] for [link_fn] and [link_abominable]

[heading:ref_constexpr_constructble [constexpr_constructble]]
* Any [@http://en.cppreference.com/w/cpp/concept/LiteralType LiteralType] that is also default-constructible

[endsect]

[section:reasons Why use [libname]?]

[*1.] [libname] offers template aliases such as `remove_function_const` for manipulating function qualifiers, designed to parallel the `<type_traits>` aliases such as `std::remove_const_t`.

[*2.] [libname] is designed to accept cv-qualified and ref-qualified types, which eliminates the need to prepare template argument types with metafunctions such as `std::remove_reference` and `std::decay`. This is especially useful when dealing with perfectly-forwarded parameter types in function templates.

[*3.] [libname] is designed in terms of the [invoke] rules, with one unobtrusive and beneficial deviation: [concept_fn] types and [concept_abominable] types are compatible with all operations that do not specifically require an invocation.

[*4.] [libns]`arg_at<2, Callable>` is both more flexible and more readable than `typename boost::function_traits<Callable>::arg3_type`.

[*5.] [libns]`can_invoke` can be used to test `INVOKE`-ability at compile-time, with value semantics. For the craziest metaprogrammers, [libns]`can_invoke_constexpr` does the same as `can_invoke` for [concept_constexpr_constructible] types, with an added check for `constexpr`-ness (Note: for `can_invoke_constexpr`, argument types must also be [concept_constexpr_constructible])

[*6.] [libns]`is_constexpr` can be used to check whether a [concept_constexpr_constructible] type is a [concept_callable] type that yields a `constexpr` result -- no arguments necessary.

[*7.] [libns]`bind` can be used by library writers to easily accept `std::placeholder` expressions anywhere, and "intercept" the type information before forwarding to `std::bind` or `boost::bind`. This allows for more flexible APIs, where a function template taking a "callable type" can be overloaded to also accept placeholder expressions. It's perhaps a small improvement from requiring `std::bind` first, but in API design, even the smallest things count. See

[*8.] [libns]`min_arity` can be used to detect the presence of default arguments on a [concept_simple_fn_obj]

[*9.] The [libname] interface mainly consists of template aliases and `constexpr std::integral_constant` functions, which are arguably preferable to `typename foo::type` and `foo::value`. While the `std::integral_constant` functions in [libname] may be a deviation from traditional type trait designs, they facilitate a metaprogramming style that uses value-semantics (a la [hana]). The functions can generally be used with either types or values, which eliminates unnecessary `decltype` usage.

[*10.] [libname] includes optional features for the manipulation and inspection of calling conventions. These features are currently deemed experimental, because they greatly increase the test surface of [libname], are platform-specific, and are not yet fully tested on any platform.

[endsect]

[section:function_sugar Use case:[^ std::function] sugar]

At the time of this writing, there are around 260 [@http://stackoverflow.com/search?q=convert+std%3A%3Abind+to+std%3A%3Afunction search results] on Stack Overflow concerning the conversion from `std::bind` to `std::function`. There are roughly 340 [@http://stackoverflow.com/search?q=convert+lambda+to+std%3A%3Afunction search results] concerning the conversion of lambdas to `std::function`. In the example below, we'll kill both birds with the same stone. The `make_function` function will leverage [libname] to...

# Create an `std::function<T>` where T is not explicitly supplied by the user
# Create an `std::function<T>` where T is the deduced "signature" of an `std::placeholders` expression.

Without real-world context, `make_function` may seem rather silly to those who know the runtime costs of type erasure. However, whenever `std::function` is required by some 3rd party API, this example might make a bit more sense.

[import ../example/make_function.cpp]
[make_function]

[endsect]

[endsect]

[section:ref Reference]

[section:headers Headers]
The simplest way to use [libname] is to include the main header file:

[include_header callable_traits]

[libname] interface is also broken down by trait into individual header files. To use only the traits you need, include one or more of the following headers, listed alphabetically:

[include_header [link callable_traits.ref_add_calling_convention add_calling_convention]]
[include_header [link callable_traits.ref_add_function_const add_function_const]]
[include_header [link callable_traits.ref_add_function_cv add_function_cv]]
[include_header [link callable_traits.ref_add_function_lvalue add_function_lvalue]]
[include_header [link callable_traits.ref_add_function_rvalue add_function_rvalue]]
[include_header [link callable_traits.ref_add_varargs add_varargs]]
[include_header [link callable_traits.ref_add_function_volatile add_function_volatile]]
[include_header [link callable_traits.ref_apply_member_pointer apply_member_pointer]]
[include_header [link callable_traits.ref_apply_return apply_return]]
[include_header [link callable_traits.ref_arg_at arg_at]]
[include_header [link callable_traits.ref_args args]]
[include_header [link callable_traits.ref_arity arity]]
[include_header [link callable_traits.ref_bind bind]]
[include_header [link callable_traits.ref_can_invoke can_invoke]]
[include_header [link callable_traits.ref_can_invoke_constexpr can_invoke_constexpr]]
[include_header [link callable_traits.ref_function_type function_type]]
[include_header [link callable_traits.ref_has_calling_convention has_calling_convention]]
[include_header [link callable_traits.ref_has_varargs has_varargs]]
[include_header [link callable_traits.ref_has_void_return has_void_return]]
[include_header [link callable_traits.ref_is_const_qualified is_const_qualified]]
[include_header [link callable_traits.ref_is_constexpr is_constexpr]]
[include_header [link callable_traits.ref_is_lvalue_qualified is_lvalue_qualified]]
[include_header [link callable_traits.ref_is_reference_qualified is_reference_qualified]]
[include_header [link callable_traits.ref_is_rvalue_qualified is_rvalue_qualified]]
[include_header [link callable_traits.ref_is_unqualified is_unqualified]]
[include_header [link callable_traits.ref_is_volatile_qualified is_volatile_qualified]]
[include_header [link callable_traits.ref_max_arity max_arity]]
[include_header [link callable_traits.ref_min_arity min_arity]]
[include_header [link callable_traits.ref_qualified_function_type qualified_function_type]]
[include_header [link callable_traits.ref_remove_calling_convention remove_calling_convention]]
[include_header [link callable_traits.ref_remove_function_const remove_function_const]]
[include_header [link callable_traits.ref_remove_function_cv remove_function_cv]]
[include_header [link callable_traits.ref_remove_member_pointer remove_member_pointer]]
[include_header [link callable_traits.ref_remove_function_reference remove_function_reference]]
[include_header [link callable_traits.ref_remove_varargs remove_varargs]]
[include_header [link callable_traits.ref_remove_function_volatile remove_function_volatile]]
[include_header [link callable_traits.ref_result_of result_of]]

[endsect]



[section:ref_add_calling_convention add_calling_convention]
`add_calling_convention<T, CcTag>` will add a calling conventions to a pointer type, where `T` is a [concept_fn_ptr] or [concept_pmf], and `CcTag` is one of the following types:

*[libns]`cdecl_tag`
*[libns]`stdcall_tag`
*[libns]`fastcall_tag`
*[libns]`pascal_tag`

For `add_calling_convention` to actually work, you must:

# Be programming on a supported platform
# Add the calling convention to a pointer type where the platform allows you to do so
# Define the appropriate macro(s) before including:
 * `CALLABLE_TRAITS_ENABLE_CDECL` for `__cdecl`
 * `CALLABLE_TRAITS_ENABLE_STDCALL` for `__stdcall`
 * `CALLABLE_TRAITS_ENABLE_FASTCALL` for `__fastcall`
 * `CALLABLE_TRAITS_ENABLE_PASCAL` for `pascal`

[warning This feature is currently considered experimental. Your [feedback] is much appreciated! ]
[heading Example - [^__fastcall] to [^__stdcall]]
[import ../example/experimental_changing_calling_conventions.cpp]
[experimental_changing_calling_conventions]
[heading Example - [^__cdecl]]
[import ../example/experimental_calling_convention_cdecl.cpp]
[experimental_calling_convention_cdecl]

[endsect]

[section:ref_add_function_const add_function_const]
TODO
[heading Example]
[import ../example/add_function_const.cpp]
[add_function_const]
[endsect]

[section:ref_add_function_cv add_function_cv]
TODO
[heading Example]
[import ../example/add_function_cv.cpp]
[add_function_cv]
[endsect]

[section:ref_add_function_lvalue add_function_lvalue]
TODO
[import ../example/add_function_lvalue.cpp]
[add_function_lvalue]
[endsect]

[section:ref_add_function_rvalue add_function_rvalue]
TODO
[import ../example/add_function_rvalue.cpp]
[add_function_rvalue]
[endsect]

[section:ref_add_varargs add_varargs]
TODO
[import ../example/add_varargs.cpp]
[add_varargs]
[endsect]

[section:ref_add_function_volatile add_function_volatile]
TODO
[endsect]

[section:ref_apply_member_pointer apply_member_pointer]
TODO
[heading Example]
[import ../example/apply_member_pointer.cpp]
[apply_member_pointer]
[endsect]

[section:ref_apply_return apply_return]
TODO
[heading Example]
[/import ../example/apply_return.cpp]
[apply_return]
[endsect]

[section:ref_arg_at arg_at]
TODO
[heading Example]
[/import ../example/arg_at.cpp]
[arg_at]
[endsect]

[section:ref_args args]
TODO
[heading Example]
[import ../example/args.cpp]
[args]
[endsect]

[section:ref_arity arity]
TODO
[heading Example]
[/import ../example/arity.cpp]
[arity]
[endsect]

[section:ref_bind bind]
TODO
[heading Example 1]
[import ../example/bind_1.cpp]
[bind_1]
[heading Example 2]
[import ../example/bind_2.cpp]
[bind_2]
[endsect]

[section:ref_can_invoke can_invoke]
TODO
[heading Example - Function Object]
[import ../example/can_invoke_function_object.cpp]
[can_invoke_function_object]
[heading Example - Member Function Pointer]
[import ../example/can_invoke_member_function_pointer.cpp]
[can_invoke_member_function_pointer]
[heading Example - Function Pointer]
[import ../example/can_invoke_function_pointer.cpp]
[can_invoke_function_pointer]
[heading Example - Function Reference]
[import ../example/can_invoke_function_reference.cpp]
[can_invoke_function_reference]
[endsect]

[section:ref_can_invoke_constexpr can_invoke_constexpr]
TODO
[heading Example - Function Object]
[import ../example/can_invoke_constexpr_function_object.cpp]
[can_invoke_constexpr_function_object]
[heading Example - Member Function Pointer]
[import ../example/can_invoke_constexpr_member_function_pointer.cpp]
[can_invoke_constexpr_member_function_pointer]
[heading Example - Function Pointer]
[import ../example/can_invoke_constexpr_function_pointer.cpp]
[can_invoke_constexpr_function_pointer]
[endsect]

[section:ref_function_type function_type]
TODO
[heading Example]
[import ../example/function_type.cpp]
[function_type]
[endsect]

[section:ref_has_calling_convention has_calling_convention]
TODO
[heading Example - [^__fastcall] to [^__stdcall]]
[experimental_changing_calling_conventions]
[endsect]

[section:ref_has_varargs has_varargs]
TODO
[heading Example]
[/import ../example/has_varargs.cpp]
[has_varargs]
[endsect]

[section:ref_has_void_return has_void_return]
TODO
[heading Example]
[/import ../example/has_void_return.cpp]
[has_void_return]
[endsect]

[section:ref_is_const_qualified is_const_qualified]
TODO
[heading Example]
[/import ../example/is_const_qualified.cpp]
[is_const_qualified]
[endsect]

[section:ref_is_constexpr is_constexpr]
TODO
[heading Example - Function Object]
[import ../example/is_constexpr_function_object.cpp]
[is_constexpr_function_object]
[heading Example - Function Pointer]
[import ../example/is_constexpr_function_pointer.cpp]
[is_constexpr_function_pointer]
[endsect]

[section:ref_is_lvalue_qualified is_lvalue_qualified]
TODO
[heading Example]
[/import ../example/is_lvalue_qualified.cpp]
[is_lvalue_qualified]
[endsect]

[section:ref_is_reference_qualified is_reference_qualified]
TODO
[heading Example]
[/import ../example/is_reference_qualified.cpp]
[is_reference_qualified]
[endsect]

[section:ref_is_rvalue_qualified is_rvalue_qualified]
TODO
[heading Example]
[/import ../example/is_rvalue_qualified.cpp]
[is_rvalue_qualified]
[endsect]

[section:ref_is_unqualified is_unqualified]
TODO
[heading Example]
[/import ../example/is_unqualified.cpp]
[is_unqualified]
[endsect]

[section:ref_is_volatile_qualified is_volatile_qualified]
TODO
[heading Example]
[/import ../example/is_volatile_qualified.cpp]
[is_volatile_qualified]
[endsect]

[section:ref_max_arity max_arity]
TODO
[heading Example]
[/import ../example/max_arity.cpp]
[max_arity]
[endsect]

[section:ref_min_arity min_arity]
TODO
[heading Example]
[/import ../example/min_arity.cpp]
[min_arity]
[endsect]

[section:ref_qualified_function_type qualified_function_type]
TODO
[heading Example]
[/import ../example/qualified_function_type.cpp]
[qualified_function_type]
[endsect]

[section:ref_remove_calling_convention remove_calling_convention]
TODO
[heading Example - [^__fastcall] to [^__stdcall]]
[experimental_changing_calling_conventions]
[endsect]

[section:ref_remove_function_const remove_function_const]
TODO
[heading Example]
[/import ../example/remove_function_const.cpp]
[remove_function_const]
[endsect]

[section:ref_remove_function_cv remove_function_cv]
TODO
[heading Example]
[/import ../example/remove_function_cv.cpp]
[remove_function_cv]
[endsect]

[section:ref_remove_member_pointer remove_member_pointer]
TODO
[heading Example]
[import ../example/remove_member_pointer.cpp]
[remove_member_pointer]
[endsect]

[section:ref_remove_function_reference remove_function_reference]
TODO
[heading Example]
[/import ../example/remove_function_reference.cpp]
[remove_function_reference]
[endsect]

[section:ref_remove_varargs remove_varargs]
TODO
[heading Example]
[/import ../example/remove_varargs.cpp]
[remove_varargs]
[endsect]

[section:ref_remove_function_volatile remove_function_volatile]
TODO
[heading Example]
[/import ../example/remove_function_volatile.cpp]
[remove_function_volatile]
[endsect]

[section:ref_result_of result_of]
TODO
[heading Example]
[import ../example/result_of.cpp]
[result_of]
[endsect]

[endsect]

[section:acknowledgements Acknowledgements]

Special thanks go to Louis Dionne, whose massive [hana] project was the original source of inspiration for [libname]. Louis' occasional encouragement and advice have been invaluable throughout the development of this project.

Robert Ramey's CppCon 2014 presentation [@https://www.youtube.com/watch?v=ACeNgqBKL7E "How you can make a Boost C++ Library"], along with the related material found at the [@http://rrsd.com/blincubator.com/ Boost Library Incubator] have been excellent resources for the development and documentation of [libname].

Finally, I'd like to thank the faculty of the Harding University Computer Science Department for their mentorship and standards of excellence.

[endsect]

[section:contact Contact]

[libname] is authored and maintained by Barrett Adair

Comments, feedback, and bug reports are ['highly] appreciated, and can be submitted in the following ways:

# Open a new issue [@https://github.com/badair/callable_traits/issues/new here] on GitHub
# Message the author [@https://gitter.im/badair/callable_traits here] on Gitter, an excellent chat service built around GitHub, with message persistence and Markdown support
# Send the author an email at
  * barrettellisadair
  * at...
  * gmail dot com
  * (excuse the anti-spam measures)

[endsect]


<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Reference</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="CallableTraits">
<link rel="up" href="../index.html" title="CallableTraits">
<link rel="prev" href="../index.html" title="CallableTraits">
<link rel="next" href="acknowledgements.html" title="Acknowledgements">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../../src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../src/images/home.png" alt="Home"></a><a accesskey="n" href="acknowledgements.html"><img src="../../src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="callable_traits.ref"></a><a class="link" href="ref.html" title="Reference">Reference</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="ref.html#callable_traits.ref.headers">Headers</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_add_calling_convention">add_calling_convention</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_add_function_const">add_function_const</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_add_function_cv">add_function_cv</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_add_function_lvalue">add_function_lvalue</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_add_function_rvalue">add_function_rvalue</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_add_varargs">add_varargs</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_add_function_volatile">add_function_volatile</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_apply_member_pointer">apply_member_pointer</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_apply_return">apply_return</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_arg_at">arg_at</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_args">args</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_arity">arity</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_bind">bind</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_can_invoke">can_invoke</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_can_invoke_constexpr">can_invoke_constexpr</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_function_type">function_type</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_has_calling_convention">has_calling_convention</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_has_varargs">has_varargs</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_has_void_return">has_void_return</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_is_const_qualified">is_const_qualified</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_is_constexpr">is_constexpr</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_is_lvalue_qualified">is_lvalue_qualified</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_is_reference_qualified">is_reference_qualified</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_is_rvalue_qualified">is_rvalue_qualified</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_is_qualified">is_qualified</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_is_volatile_qualified">is_volatile_qualified</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_max_arity">max_arity</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_min_arity">min_arity</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_qualified_function_type">qualified_function_type</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_remove_calling_convention">remove_calling_convention</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_remove_function_const">remove_function_const</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_remove_function_cv">remove_function_cv</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_remove_member_pointer">remove_member_pointer</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_remove_function_reference">remove_function_reference</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_remove_varargs">remove_varargs</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_remove_function_volatile">remove_function_volatile</a></span></dt>
<dt><span class="section"><a href="ref.html#callable_traits.ref.ref_result_of">result_of</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.headers"></a><a class="link" href="ref.html#callable_traits.ref.headers" title="Headers">Headers</a>
</h3></div></div></div>
<p>
        The simplest way to use <code class="literal">CallableTraits</code> is to include the
        main header file:
      </p>
<p>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal">callable_traits</code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
      </p>
<p>
        <code class="literal">CallableTraits</code> interface is also broken down by trait
        into individual header files. To use only the traits you need, include one
        or more of the following headers, listed alphabetically:
      </p>
<p>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">add_calling_convention</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">add_function_const</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">add_function_cv</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">add_function_lvalue</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">add_function_rvalue</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">add_varargs</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">add_function_volatile</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">apply_member_pointer</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">apply_return</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">arg_at</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">args</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">arity</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">bind</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">can_invoke</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">can_invoke_constexpr</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">function_type</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">has_calling_convention</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">has_varargs</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">has_void_return</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">is_const_qualified</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">is_constexpr</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">is_lvalue_qualified</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">is_reference_qualified</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">is_rvalue_qualified</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">is_qualified</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">is_volatile_qualified</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">max_arity</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">min_arity</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">qualified_function_type</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">remove_calling_convention</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">remove_function_const</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">remove_function_cv</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">remove_member_pointer</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">remove_function_reference</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">remove_varargs</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">remove_function_volatile</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        <code class="computeroutput"><span class="preprocessor">#include</span><span class="special">&lt;</span></code><code class="literal">callable_traits/</code><code class="literal"><a class="link" href="../">result_of</a></code><code class="computeroutput"><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_add_calling_convention"></a><a class="link" href="ref.html#callable_traits.ref.ref_add_calling_convention" title="add_calling_convention">add_calling_convention</a>
</h3></div></div></div>
<p>
        <code class="computeroutput"><span class="identifier">add_calling_convention</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">CcTag</span><span class="special">&gt;</span></code> will add a calling conventions to a pointer
        type, where <code class="computeroutput"><span class="identifier">T</span></code> is a <span class="green">FunctionPtr</span> or <span class="green">MemberFunctionPtr</span>,
        and <code class="computeroutput"><span class="identifier">CcTag</span></code> is one of the following
        types:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="literal">callable_traits::</code><code class="computeroutput"><span class="identifier">cdecl_tag</span></code>
          </li>
<li class="listitem">
            <code class="literal">callable_traits::</code><code class="computeroutput"><span class="identifier">stdcall_tag</span></code>
          </li>
<li class="listitem">
            <code class="literal">callable_traits::</code><code class="computeroutput"><span class="identifier">fastcall_tag</span></code>
          </li>
<li class="listitem">
            <code class="literal">callable_traits::</code><code class="computeroutput"><span class="identifier">pascal_tag</span></code>
          </li>
</ul></div>
<p>
        For <code class="computeroutput"><span class="identifier">add_calling_convention</span></code>
        to actually work, you must:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            Be programming on a supported platform
          </li>
<li class="listitem">
            Add the calling convention to a pointer type where the platform allows
            you to do so
          </li>
<li class="listitem">
            Define the appropriate macro(s) before including:
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                  <code class="computeroutput"><span class="identifier">CALLABLE_TRAITS_ENABLE_CDECL</span></code>
                  for <code class="computeroutput"><span class="identifier">__cdecl</span></code>
                </li>
<li class="listitem">
                  <code class="computeroutput"><span class="identifier">CALLABLE_TRAITS_ENABLE_STDCALL</span></code>
                  for <code class="computeroutput"><span class="identifier">__stdcall</span></code>
                </li>
<li class="listitem">
                  <code class="computeroutput"><span class="identifier">CALLABLE_TRAITS_ENABLE_FASTCALL</span></code>
                  for <code class="computeroutput"><span class="identifier">__fastcall</span></code>
                </li>
<li class="listitem">
                  <code class="computeroutput"><span class="identifier">CALLABLE_TRAITS_ENABLE_PASCAL</span></code>
                  for <code class="computeroutput"><span class="identifier">pascal</span></code>
                </li>
</ul></div>
          </li>
</ol></div>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          This feature is currently considered experimental. Your <a class="link" href="contact.html" title="Contact">feedback</a>
          is much appreciated!
        </p></td></tr>
</table></div>
<h5>
<a name="callable_traits.ref.ref_add_calling_convention.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_add_calling_convention.example_fastcall_to_stdcall"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_add_calling_convention.example_fastcall_to_stdcall">Example
        - <code class="literal">__fastcall</code> to <code class="literal">__stdcall</code></a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">CALLABLE_TRAITS_ENABLE_STDCALL</span>
<span class="preprocessor">#define</span> <span class="identifier">CALLABLE_TRAITS_ENABLE_FASTCALL</span>

<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">has_calling_convention</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">add_calling_convention</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">remove_calling_convention</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="keyword">using</span> <span class="identifier">f</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">__fastcall</span> <span class="special">*)(</span><span class="keyword">int</span><span class="special">);</span>

    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">fastcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
    <span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">stdcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>

    <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">__stdcall</span> <span class="special">*)(</span><span class="keyword">int</span><span class="special">);</span>

    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">expect</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">stdcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
    <span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">expect</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">fastcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>

    <span class="keyword">using</span> <span class="identifier">g</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">remove_calling_convention</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">&gt;;</span>
    <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_calling_convention</span><span class="special">&lt;</span><span class="identifier">g</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">stdcall_tag</span><span class="special">&gt;;</span>

    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">stdcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<h5>
<a name="callable_traits.ref.ref_add_calling_convention.h1"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_add_calling_convention.example_cdecl"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_add_calling_convention.example_cdecl">Example
        - <code class="literal">__cdecl</code></a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">CALLABLE_TRAITS_ENABLE_CDECL</span>

<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">has_calling_convention</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">add_calling_convention</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">foo</span> <span class="special">{};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="comment">//depending on your platform, pmf may already have an implicit __cdecl</span>
    <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)();</span>
    <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">__cdecl</span> <span class="identifier">foo</span><span class="special">::*)();</span>
    <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_calling_convention</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">cdecl_tag</span><span class="special">&gt;;</span>

    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">expect</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">cdecl_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">cdecl_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_add_function_const"></a><a class="link" href="ref.html#callable_traits.ref.ref_add_function_const" title="add_function_const">add_function_const</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_add_function_const.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_add_function_const.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_add_function_const.example">Example</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">add_function_const</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">foo</span> <span class="special">{};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)();</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="keyword">const</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_const</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// add_function_const doesn't change anything when</span>
        <span class="comment">// the function type is already const.</span>
        <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="keyword">const</span> <span class="special">&amp;&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="keyword">const</span> <span class="special">&amp;&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_const</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="keyword">volatile</span> <span class="special">&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="special">&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_const</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// add_function_const can also be used with "abominable"</span>
        <span class="comment">// function types.</span>
        <span class="keyword">using</span> <span class="identifier">f</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">();</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_const</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// add_function_const does not compile with function pointers,</span>
        <span class="comment">// function references, function objects, or member data pointers.</span>
        <span class="comment">// However, you can loosen this restriction somewhat by using the</span>
        <span class="comment">// callable_traits::permissive namespace instead:</span>
        <span class="keyword">using</span> <span class="identifier">f</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(*)();</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="identifier">f</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">permissive</span><span class="special">::</span><span class="identifier">add_function_const</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_add_function_cv"></a><a class="link" href="ref.html#callable_traits.ref.ref_add_function_cv" title="add_function_cv">add_function_cv</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_add_function_cv.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_add_function_cv.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_add_function_cv.example">Example</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">add_function_cv</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">foo</span> <span class="special">{};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)();</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="keyword">const</span> <span class="keyword">volatile</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_cv</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// add_function_cv doesn't change anything when</span>
        <span class="comment">// the function type is already cv-qualified.</span>
        <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="special">&amp;&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="special">&amp;&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_cv</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="keyword">volatile</span> <span class="special">&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="special">&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_cv</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// add_function_cv can also be used with "abominable"</span>
        <span class="comment">// function types.</span>
        <span class="keyword">using</span> <span class="identifier">f</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">();</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">volatile</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_cv</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// add_function_cv does not compile with function pointers,</span>
        <span class="comment">// function references, function objects, or member data pointers.</span>
        <span class="comment">// However, you can loosen this restriction somewhat by using the</span>
        <span class="comment">// callable_traits::permissive namespace instead:</span>
        <span class="keyword">using</span> <span class="identifier">f</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(*)();</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="identifier">f</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">permissive</span><span class="special">::</span><span class="identifier">add_function_cv</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_add_function_lvalue"></a><a class="link" href="ref.html#callable_traits.ref.ref_add_function_lvalue" title="add_function_lvalue">add_function_lvalue</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">add_function_lvalue</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">foo</span> <span class="special">{};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)();</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="special">&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_lvalue</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// add_function_lvalue doesn't change anything when</span>
        <span class="comment">// the function type already has an lvalue qualifier.</span>
        <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="special">&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="special">&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_lvalue</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// add_function_lvalue models C++11 reference collapsing</span>
        <span class="comment">// rules, so that adding an lvalue qualifier to an</span>
        <span class="comment">// rvalue-qualified type will force the lvalue.</span>
        <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="special">&amp;&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="special">&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_lvalue</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// add_function_lvalue can also be used to create "abominable"</span>
        <span class="comment">// function types.</span>
        <span class="keyword">using</span> <span class="identifier">f</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">();</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">()</span> <span class="special">&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_lvalue</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// add_function_lvalue does not compile with function pointers,</span>
        <span class="comment">// function references, function objects, or member data pointers.</span>
        <span class="comment">// However, you can loosen this restriction somewhat by using the</span>
        <span class="comment">// callable_traits::permissive namespace instead:</span>
        <span class="keyword">using</span> <span class="identifier">f</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(*)();</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="identifier">f</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">permissive</span><span class="special">::</span><span class="identifier">add_function_lvalue</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_add_function_rvalue"></a><a class="link" href="ref.html#callable_traits.ref.ref_add_function_rvalue" title="add_function_rvalue">add_function_rvalue</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">add_function_rvalue</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">foo</span> <span class="special">{};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)();</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="special">&amp;&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_rvalue</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// add_function_rvalue doesn't change anything when</span>
        <span class="comment">// the function type already has an rvalue qualifier.</span>
        <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="special">&amp;&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="special">&amp;&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_rvalue</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// add_function_rvalue models C++11 reference collapsing</span>
        <span class="comment">// rules, so that adding an rvalue qualifier to an</span>
        <span class="comment">// lvalue-qualified type will not change anything.</span>
        <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="keyword">const</span> <span class="special">&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="keyword">const</span> <span class="special">&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_rvalue</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// add_function_rvalue can also be used with "abominable"</span>
        <span class="comment">// function types.</span>
        <span class="keyword">using</span> <span class="identifier">f</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">&amp;&amp;;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_function_rvalue</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// add_function_rvalue does not compile with function pointers,</span>
        <span class="comment">// function references, function objects, or member data pointers.</span>
        <span class="comment">// However, you can loosen this restriction somewhat by using the</span>
        <span class="comment">// callable_traits::permissive namespace instead:</span>
        <span class="keyword">using</span> <span class="identifier">f</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(*)();</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="identifier">f</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">permissive</span><span class="special">::</span><span class="identifier">add_function_rvalue</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_add_varargs"></a><a class="link" href="ref.html#callable_traits.ref.ref_add_varargs" title="add_varargs">add_varargs</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">add_varargs</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">foo</span> <span class="special">{};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">f</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="keyword">int</span><span class="special">);</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="special">...);</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_varargs</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">fp</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(*)();</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(*)(...);</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_varargs</span><span class="special">&lt;</span><span class="identifier">fp</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">fr</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(&amp;)(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*);</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(&amp;)(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*,</span> <span class="special">...);</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_varargs</span><span class="special">&lt;</span><span class="identifier">fr</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="keyword">const</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)(...)</span> <span class="keyword">const</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_varargs</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>

        <span class="comment">// add_varargs doesn't change anything when</span>
        <span class="comment">// the type already has varargs.</span>
        <span class="keyword">using</span> <span class="identifier">twice</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_varargs</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">twice</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// add_varargs fails in a SFINAE-friendly manner when</span>
    <span class="comment">// used on a function object or a member data pointer.</span>
    <span class="comment">//</span>
    <span class="comment">// {</span>
    <span class="comment">//     using d = int foo::*;</span>
    <span class="comment">//     using test = ct::add_varargs&lt;d&gt;;</span>
    <span class="comment">// }</span>
    <span class="comment">//</span>
    <span class="comment">// The error message is about as obvious as it can be without</span>
    <span class="comment">// resorting to a SFINAE-unfriendly static_assert (namespaces</span>
    <span class="comment">// omitted for brevity):</span>
    <span class="comment">//</span>
    <span class="comment">//   error: no type named 'type' in 'struct disjunction&lt;</span>
    <span class="comment">//   type_value&lt;invalid_type, false&gt;, add_varargs_error&lt;0&gt; &gt;'</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_add_function_volatile"></a><a class="link" href="ref.html#callable_traits.ref.ref_add_function_volatile" title="add_function_volatile">add_function_volatile</a>
</h3></div></div></div>
<p>
        TODO
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_apply_member_pointer"></a><a class="link" href="ref.html#callable_traits.ref.ref_apply_member_pointer" title="apply_member_pointer">apply_member_pointer</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_apply_member_pointer.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_apply_member_pointer.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_apply_member_pointer.example">Example</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">apply_member_pointer</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">foo</span><span class="special">;</span>
<span class="keyword">struct</span> <span class="identifier">bar</span><span class="special">;</span>

<span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">int</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)(</span><span class="keyword">int</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">test</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">U</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">apply_member_pointer</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">foo</span><span class="special">&gt;;</span>
    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">expect</span><span class="special">,</span> <span class="identifier">U</span><span class="special">&gt;{},</span> <span class="string">""</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(</span><span class="keyword">int</span><span class="special">)&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(*)(</span><span class="keyword">int</span><span class="special">)&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(*&amp;)(</span><span class="keyword">int</span><span class="special">)&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(*</span> <span class="keyword">const</span><span class="special">)(</span><span class="keyword">int</span><span class="special">)&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(&amp;)(</span><span class="keyword">int</span><span class="special">)&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)(</span><span class="keyword">int</span><span class="special">)&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(</span><span class="identifier">bar</span><span class="special">::*)(</span><span class="keyword">int</span><span class="special">)&gt;();</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_apply_return"></a><a class="link" href="ref.html#callable_traits.ref.ref_apply_return" title="apply_return">apply_return</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_apply_return.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_apply_return.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_apply_return.example">Example</a>
      </h5>
<p>
        [apply_return]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_arg_at"></a><a class="link" href="ref.html#callable_traits.ref.ref_arg_at" title="arg_at">arg_at</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_arg_at.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_arg_at.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_arg_at.example">Example</a>
      </h5>
<p>
        [arg_at]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_args"></a><a class="link" href="ref.html#callable_traits.ref.ref_args" title="args">args</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_args.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_args.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_args.example">Example</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">memory</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="comment">// all callable types in this example use these parameter types</span>
<span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">&amp;,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*&gt;;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">test</span><span class="special">(){</span>
    <span class="comment">// this example shows how callable_traits::args</span>
    <span class="comment">// bevaves consistently for many different types</span>
    <span class="keyword">using</span> <span class="identifier">args</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">args</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;;</span>
    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">expect</span><span class="special">,</span> <span class="identifier">args</span><span class="special">&gt;{},</span> <span class="string">""</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>


    <span class="keyword">auto</span> <span class="identifier">lamda</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">&amp;,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*){};</span>
    <span class="keyword">using</span> <span class="identifier">lam</span> <span class="special">=</span> <span class="keyword">decltype</span><span class="special">(</span><span class="identifier">lamda</span><span class="special">);</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">lam</span><span class="special">&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">lam</span><span class="special">&amp;&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">lam</span><span class="special">&amp;&amp;&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">lam</span> <span class="keyword">const</span> <span class="special">&amp;&gt;();</span>

    <span class="keyword">struct</span> <span class="identifier">foo</span><span class="special">;</span>
    <span class="keyword">using</span> <span class="identifier">pmf</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">&amp;,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*);</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&amp;&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">pmf</span><span class="special">&amp;&amp;&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">pmf</span> <span class="keyword">const</span> <span class="special">&amp;&gt;();</span>

    <span class="keyword">using</span> <span class="identifier">function_ptr</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(*)(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">&amp;,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*);</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">function_ptr</span><span class="special">&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">function_ptr</span><span class="special">&amp;&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">function_ptr</span><span class="special">&amp;&amp;&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">function_ptr</span> <span class="keyword">const</span> <span class="special">&amp;&gt;();</span>

    <span class="keyword">using</span> <span class="identifier">function_ref</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(&amp;)(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">&amp;,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*);</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">function_ref</span><span class="special">&gt;();</span>

    <span class="keyword">using</span> <span class="identifier">function</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">&amp;,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*);</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">function</span><span class="special">&gt;();</span>

    <span class="keyword">using</span> <span class="identifier">abominable</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">&amp;,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*)</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">abominable</span><span class="special">&gt;();</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_arity"></a><a class="link" href="ref.html#callable_traits.ref.ref_arity" title="arity">arity</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_arity.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_arity.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_arity.example">Example</a>
      </h5>
<p>
        [arity]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_bind"></a><a class="link" href="ref.html#callable_traits.ref.ref_bind" title="bind">bind</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_bind.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_bind.example_1"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_bind.example_1">Example
        1</a>
      </h5>
<pre class="programlisting"><span class="comment">/* In this example, the last _1 placeholder in the bind
expression forces all other _1 slots to accept ScaryMonster,
because ScaryMonster is the narrowest of all _1 parameters. */</span>

<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cassert</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">functional</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">tuple</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">struct</span> <span class="identifier">Vampire</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">Robot</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">Animal</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">Dog</span> <span class="special">:</span> <span class="identifier">Animal</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">Poodle</span> <span class="special">:</span> <span class="identifier">Dog</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">ScaryMonster</span> <span class="special">:</span> <span class="identifier">Vampire</span><span class="special">,</span> <span class="identifier">Robot</span><span class="special">,</span> <span class="identifier">Poodle</span> <span class="special">{};</span>

<span class="keyword">auto</span> <span class="identifier">vampire_to_robot</span><span class="special">(</span><span class="identifier">Vampire</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">Robot</span><span class="special">{};</span>
<span class="special">}</span>

<span class="keyword">auto</span> <span class="identifier">robot_to_dog</span> <span class="special">=</span> <span class="special">[](</span><span class="identifier">Robot</span><span class="special">){</span>
    <span class="keyword">return</span> <span class="identifier">Dog</span><span class="special">{};</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">converter</span> <span class="special">{</span>
    <span class="keyword">auto</span> <span class="identifier">dog_to_vampire</span><span class="special">(</span><span class="identifier">Dog</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">Vampire</span><span class="special">{};</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">take_all</span><span class="special">(</span><span class="identifier">Vampire</span><span class="special">,</span> <span class="identifier">Robot</span><span class="special">,</span> <span class="identifier">Animal</span><span class="special">,</span> <span class="identifier">Dog</span><span class="special">,</span> <span class="identifier">Poodle</span><span class="special">,</span> <span class="identifier">ScaryMonster</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">placeholders</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="keyword">auto</span> <span class="identifier">b</span> <span class="special">=</span>
        <span class="identifier">ct</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">take_all</span><span class="special">,</span>
            <span class="identifier">ct</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">converter</span><span class="special">::</span><span class="identifier">dog_to_vampire</span><span class="special">,</span>
                <span class="identifier">converter</span><span class="special">{},</span>
                <span class="identifier">ct</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span><span class="identifier">robot_to_dog</span><span class="special">,</span>
                    <span class="identifier">ct</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">vampire_to_robot</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">)</span>
                <span class="special">)</span>
            <span class="special">),</span>
            <span class="identifier">ct</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">vampire_to_robot</span><span class="special">,</span> <span class="identifier">_3</span><span class="special">),</span>
            <span class="identifier">Animal</span><span class="special">{},</span>
            <span class="identifier">_1</span><span class="special">,</span>
            <span class="identifier">_2</span><span class="special">,</span>
            <span class="identifier">_1</span>
        <span class="special">);</span>

    <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">args</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">args</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">b</span><span class="special">)&gt;;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">ScaryMonster</span><span class="special">,</span> <span class="identifier">Poodle</span><span class="special">,</span> <span class="identifier">Vampire</span><span class="special">&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">args</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">type</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">function_type</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">b</span><span class="special">)&gt;;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">int</span><span class="special">(</span><span class="identifier">ScaryMonster</span><span class="special">,</span> <span class="identifier">Poodle</span><span class="special">,</span> <span class="identifier">Vampire</span><span class="special">);</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">b</span><span class="special">(</span><span class="identifier">ScaryMonster</span><span class="special">{},</span> <span class="identifier">Poodle</span><span class="special">{},</span> <span class="identifier">Vampire</span><span class="special">{})</span> <span class="special">==</span> <span class="number">0</span><span class="special">);</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<h5>
<a name="callable_traits.ref.ref_bind.h1"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_bind.example_2"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_bind.example_2">Example
        2</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cassert</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">functional</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">tuple</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">struct</span> <span class="identifier">Vampire</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">Robot</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">Animal</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">Dog</span> <span class="special">:</span> <span class="identifier">Animal</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">Poodle</span> <span class="special">:</span> <span class="identifier">Dog</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">ScaryMonster</span> <span class="special">:</span> <span class="identifier">Poodle</span><span class="special">,</span> <span class="identifier">Robot</span><span class="special">,</span> <span class="identifier">Vampire</span> <span class="special">{};</span>

<span class="keyword">auto</span> <span class="identifier">take_vampire</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Vampire</span><span class="special">&amp;)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span> <span class="special">}</span>
<span class="keyword">auto</span> <span class="identifier">take_robot</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Robot</span><span class="special">&amp;)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span> <span class="special">}</span>
<span class="keyword">auto</span> <span class="identifier">take_dog</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Dog</span><span class="special">&amp;)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span> <span class="special">}</span>
<span class="keyword">auto</span> <span class="identifier">take_scary_monster</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">ScaryMonster</span><span class="special">&amp;)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span> <span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span> <span class="special">}</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">placeholders</span><span class="special">;</span>
<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="identifier">ScaryMonster</span> <span class="identifier">monster</span><span class="special">{};</span>

    <span class="keyword">auto</span> <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span>
        <span class="special">&amp;</span><span class="identifier">f</span><span class="special">,</span>
        <span class="identifier">ct</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">take_vampire</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">),</span>
        <span class="identifier">ct</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">take_robot</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">),</span>
        <span class="identifier">ct</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">take_dog</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">),</span>
        <span class="identifier">ct</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">take_scary_monster</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">)</span>
    <span class="special">);</span>

    <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">args</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">args</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">b</span><span class="special">)&gt;;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">ScaryMonster</span><span class="special">&amp;&gt;;</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">args</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">type</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">function_type</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">b</span><span class="special">)&gt;;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">int</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">ScaryMonster</span><span class="special">&amp;);</span>
        <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">b</span><span class="special">(</span><span class="identifier">monster</span><span class="special">)</span> <span class="special">==</span> <span class="number">0</span><span class="special">);</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_can_invoke"></a><a class="link" href="ref.html#callable_traits.ref.ref_can_invoke" title="can_invoke">can_invoke</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_can_invoke.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_can_invoke.example_function_object"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_can_invoke.example_function_object">Example
        - Function Object</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="comment">// For the purpose of this example, 'Bad' represents</span>
<span class="comment">// any non-arithmetic type</span>
<span class="keyword">struct</span> <span class="identifier">Bad</span> <span class="special">{};</span>
<span class="identifier">Bad</span> <span class="identifier">bad</span><span class="special">{};</span>

<span class="comment">// non-generic callables, such as `subtract` below,</span>
<span class="comment">// don't have any "gotchas" when passed to</span>
<span class="comment">// callable_traits::can_invoke.</span>
<span class="keyword">auto</span> <span class="identifier">subtract</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">int</span> <span class="identifier">x</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">y</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">x</span> <span class="special">+</span> <span class="identifier">y</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">subtract</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">subtract</span><span class="special">,</span> <span class="number">1</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">subtract</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="number">2</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span> <span class="comment">// &lt;-- success</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">subtract</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="number">2</span><span class="special">,</span> <span class="number">3</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">subtract</span><span class="special">,</span> <span class="identifier">bad</span><span class="special">,</span> <span class="identifier">bad</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>

<span class="comment">// Generic function objects (such as `add` and `multiply` below)</span>
<span class="comment">// must be SFINAE-friendly in order for failing can_invoke calls</span>
<span class="comment">// to actually compile. This applies to both generic lambdas and</span>
<span class="comment">// templated function objects. Note: MSVC does not compile this</span>
<span class="comment">// source code file because of the trailing return type below (MSVC</span>
<span class="comment">// is non-conforming in this respect)</span>

<span class="keyword">auto</span> <span class="identifier">add</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="identifier">x</span><span class="special">,</span> <span class="keyword">auto</span> <span class="identifier">y</span><span class="special">)</span> <span class="special">-&gt;</span> <span class="keyword">decltype</span><span class="special">(</span><span class="identifier">x</span> <span class="special">+</span> <span class="identifier">y</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">x</span> <span class="special">+</span> <span class="identifier">y</span><span class="special">;</span>          <span class="comment">// ^^^^^^^^^^^^^^^^^^ explicit return type allows SFINAE</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="identifier">int_c</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">integral_constant</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">I</span><span class="special">&gt;;</span>

<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">add</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">add</span><span class="special">,</span> <span class="number">1</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">add</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="number">2</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span> <span class="comment">// &lt;-- success</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">add</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="number">2</span><span class="special">,</span> <span class="number">3</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">add</span><span class="special">,</span> <span class="identifier">bad</span><span class="special">,</span> <span class="identifier">bad</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>

<span class="comment">// 'multiply' isn't SFINAE-safe, because the return type depends</span>
<span class="comment">// on an expression in the body. However, it still works if we</span>
<span class="comment">// only try to call can_invoke with arguments where x * y is</span>
<span class="comment">// a valid expression.</span>
<span class="keyword">auto</span> <span class="identifier">multiply</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="identifier">x</span><span class="special">,</span> <span class="keyword">auto</span> <span class="identifier">y</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">x</span> <span class="special">*</span> <span class="identifier">y</span><span class="special">;</span>
<span class="special">};</span>


<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">multiply</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">multiply</span><span class="special">,</span> <span class="number">1</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">multiply</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="number">2</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span> <span class="comment">// &lt;-- success</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">multiply</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="number">2</span><span class="special">,</span> <span class="number">3</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>
<span class="comment">//static_assert(!ct::can_invoke(multiply, bad, bad), "");</span>

<span class="comment">// The last, commented static_assert above would fail compile,</span>
<span class="comment">// because the call cannot be SFINAE'd away. Error message in Clang:</span>
<span class="comment">// "invalid operands to binary expression ('Bad' and 'Bad')"</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{}</span>
</pre>
<h5>
<a name="callable_traits.ref.ref_can_invoke.h1"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_can_invoke.example_member_function_pointer"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_can_invoke.example_member_function_pointer">Example
        - Member Function Pointer</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">foo</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">bar</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// can_invoke returns std::true_type here because the</span>
<span class="comment">// arguments are valid to INVOKE</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">::</span><span class="identifier">bar</span><span class="special">,</span> <span class="identifier">foo</span><span class="special">{},</span> <span class="number">0</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>

<span class="comment">// can_invoke returns std::false_type here because the</span>
<span class="comment">// arguments are NOT valid to INVOKE - foo::bar can't be</span>
<span class="comment">// invoked like a void member function.</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">::</span><span class="identifier">bar</span><span class="special">,</span> <span class="identifier">foo</span><span class="special">{}),</span> <span class="string">""</span><span class="special">);</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{}</span>
</pre>
<h5>
<a name="callable_traits.ref.ref_can_invoke.h2"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_can_invoke.example_function_pointer"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_can_invoke.example_function_pointer">Example
        - Function Pointer</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">foo</span><span class="special">(</span><span class="keyword">int</span><span class="special">&amp;&amp;</span> <span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">i</span><span class="special">;</span>
<span class="special">}</span>

<span class="comment">// can_invoke returns std::true_type here because the</span>
<span class="comment">// arguments are valid to INVOKE</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">,</span> <span class="number">0</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>

<span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>

<span class="comment">// can_invoke returns std::false_type here because the</span>
<span class="comment">// arguments are NOT valid to INVOKE - foo expects an</span>
<span class="comment">// rvalue reference, not an lvalue reference.</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">,</span> <span class="identifier">i</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{}</span>
</pre>
<h5>
<a name="callable_traits.ref.ref_can_invoke.h3"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_can_invoke.example_function_reference"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_can_invoke.example_function_reference">Example
        - Function Reference</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">foo</span><span class="special">(</span><span class="keyword">int</span><span class="special">&amp;&amp;</span> <span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">i</span><span class="special">;</span>
<span class="special">}</span>

<span class="comment">// can_invoke returns std::true_type here because the</span>
<span class="comment">// arguments are valid to INVOKE</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">foo</span><span class="special">,</span> <span class="number">0</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>

<span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>

<span class="comment">// can_invoke returns std::false_type here because the</span>
<span class="comment">// arguments are NOT valid to INVOKE - foo expects an</span>
<span class="comment">// rvalue reference, not an lvalue reference.</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke</span><span class="special">(</span><span class="identifier">foo</span><span class="special">,</span> <span class="identifier">i</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_can_invoke_constexpr"></a><a class="link" href="ref.html#callable_traits.ref.ref_can_invoke_constexpr" title="can_invoke_constexpr">can_invoke_constexpr</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_can_invoke_constexpr.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_can_invoke_constexpr.example_function_object"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_can_invoke_constexpr.example_function_object">Example
        - Function Object</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="comment">// NOTE: Due to non-compliance in MSVC, can_invoke_constexpr</span>
<span class="comment">// always return std::false_type on that compiler, which causes</span>
<span class="comment">// the static asserts below to fail.</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">using</span> <span class="identifier">T1</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">integral_constant</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="number">3</span><span class="special">&gt;;</span>
<span class="keyword">using</span> <span class="identifier">T2</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">integral_constant</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="number">7</span><span class="special">&gt;;</span>

<span class="comment">//'subtract' is a constexpr function object that</span>
<span class="comment">// subtracts std::integral_constant types.</span>
<span class="keyword">struct</span> <span class="identifier">subtract</span> <span class="special">{</span>

    <span class="comment">// To compile failing cases of can_invoke_constexpr, the function object</span>
    <span class="comment">// must have a SFINAE-safe signature. In this case, 'subtract' is made</span>
    <span class="comment">// SFINAE-safe with an explicit, trailing return type.</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">&gt;</span>
    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">-&gt;</span> <span class="keyword">decltype</span><span class="special">(</span><span class="identifier">T1</span><span class="special">::</span><span class="identifier">value</span> <span class="special">-</span> <span class="identifier">T2</span><span class="special">::</span><span class="identifier">value</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">T1</span><span class="special">::</span><span class="identifier">value</span> <span class="special">-</span> <span class="identifier">T2</span><span class="special">::</span><span class="identifier">value</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// can_invoke_constexpr returns std::true_type in the first case, because</span>
<span class="comment">// INVOKE(subtract{}, T1{}, T2{}) is a valid expression, AND 'subtract{}' is</span>
<span class="comment">// a constexpr function object.</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke_constexpr</span><span class="special">(</span><span class="identifier">subtract</span><span class="special">{},</span> <span class="identifier">T1</span><span class="special">{},</span> <span class="identifier">T2</span><span class="special">{}),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke_constexpr</span><span class="special">(</span><span class="identifier">subtract</span><span class="special">{},</span> <span class="number">3</span><span class="special">,</span> <span class="number">7</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke_constexpr</span><span class="special">(</span><span class="identifier">subtract</span><span class="special">{},</span> <span class="identifier">T1</span><span class="special">{}),</span> <span class="string">""</span><span class="special">);</span>

<span class="comment">//this is a function object, but is NOT constexpr</span>
<span class="keyword">struct</span> <span class="identifier">add</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">&gt;</span>
    <span class="keyword">auto</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">-&gt;</span> <span class="keyword">decltype</span><span class="special">(</span><span class="identifier">T1</span><span class="special">::</span><span class="identifier">value</span> <span class="special">+</span> <span class="identifier">T2</span><span class="special">::</span><span class="identifier">value</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">T1</span><span class="special">::</span><span class="identifier">value</span> <span class="special">+</span> <span class="identifier">T2</span><span class="special">::</span><span class="identifier">value</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Even though INVOKE(add{}, T1{}, T2{}) is valid, the respective</span>
<span class="comment">// can_invoke_constexpr call returns std::false_type because 'add{}'</span>
<span class="comment">// is not a constexpr function object.</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke_constexpr</span><span class="special">(</span><span class="identifier">add</span><span class="special">{},</span> <span class="identifier">T1</span><span class="special">{},</span> <span class="identifier">T2</span><span class="special">{}),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke_constexpr</span><span class="special">(</span><span class="identifier">add</span><span class="special">{},</span> <span class="number">3</span><span class="special">,</span> <span class="number">7</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>


<span class="comment">// This last section demonstrates that can_invoke_constexpr will always</span>
<span class="comment">// return std::false_type when any of the arguments do not decay to literal</span>
<span class="comment">// types. (see http://en.cppreference.com/w/cpp/concept/LiteralType).</span>
<span class="comment">// Even though 'S' below is a constexpr function object, it is incompatible</span>
<span class="comment">// with can_invoke_constexpr because 'S' isn't a literal type. Additionally,</span>
<span class="comment">// all arguments must be default constructible.</span>

<span class="keyword">struct</span> <span class="identifier">S</span> <span class="special">{</span>
    <span class="identifier">S</span><span class="special">()</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">S</span><span class="special">(</span><span class="keyword">int</span><span class="special">){};</span>
    <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="keyword">operator</span><span class="special">()()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span> <span class="special">}</span>
<span class="special">};</span>

<span class="identifier">S</span> <span class="identifier">s</span><span class="special">{</span><span class="number">0</span><span class="special">};</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke_constexpr</span><span class="special">(</span><span class="identifier">s</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>


<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{}</span>
</pre>
<h5>
<a name="callable_traits.ref.ref_can_invoke_constexpr.h1"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_can_invoke_constexpr.example_member_function_pointer"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_can_invoke_constexpr.example_member_function_pointer">Example
        - Member Function Pointer</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="comment">// NOTE: Due to non-compliance in MSVC, can_invoke_constexpr</span>
<span class="comment">// always returns std::false_type on that compiler, which</span>
<span class="comment">// causes a static assert below to fail.</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">foo</span> <span class="special">{</span>
    <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="identifier">bar</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">using</span> <span class="identifier">pmf_constant</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">integral_constant</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">::</span><span class="identifier">bar</span><span class="special">),</span> <span class="special">&amp;</span><span class="identifier">foo</span><span class="special">::</span><span class="identifier">bar</span><span class="special">&gt;;</span>

<span class="comment">// can_invoke_constexpr returns true here because foo::bar</span>
<span class="comment">// is constexpr, and the arguments are valid to INVOKE</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke_constexpr</span><span class="special">(</span><span class="identifier">pmf_constant</span><span class="special">{},</span> <span class="identifier">foo</span><span class="special">{},</span> <span class="number">0</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>

<span class="comment">// can_invoke_constexpr returns false here because even though</span>
<span class="comment">// foo::bar is constexpr, the arguments do not obey INVOKE rules</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke_constexpr</span><span class="special">(</span><span class="identifier">pmf_constant</span><span class="special">{},</span> <span class="identifier">foo</span><span class="special">{}),</span> <span class="string">""</span><span class="special">);</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{}</span>
</pre>
<h5>
<a name="callable_traits.ref.ref_can_invoke_constexpr.h2"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_can_invoke_constexpr.example_function_pointer"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_can_invoke_constexpr.example_function_pointer">Example
        - Function Pointer</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="identifier">seven</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="number">7</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">using</span> <span class="identifier">seven_c</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">integral_constant</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(&amp;</span><span class="identifier">seven</span><span class="special">),</span> <span class="special">&amp;</span><span class="identifier">seven</span><span class="special">&gt;;</span>

<span class="comment">// The first call to can_invoke_constexpr returns std::true_type</span>
<span class="comment">// because `seven` is a constexpr function, and valid INVOKE arguments</span>
<span class="comment">// are passed. The second call to can_invoke_constexpr returns</span>
<span class="comment">// std::false_type, because the arguments are not valid to INVOKE</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke_constexpr</span><span class="special">(</span><span class="identifier">seven_c</span><span class="special">{},</span> <span class="number">0</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke_constexpr</span><span class="special">(</span><span class="identifier">seven_c</span><span class="special">{},</span> <span class="keyword">nullptr</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>

<span class="keyword">int</span> <span class="identifier">eight</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="number">7</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">using</span> <span class="identifier">eight_c</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">integral_constant</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(&amp;</span><span class="identifier">eight</span><span class="special">),</span> <span class="special">&amp;</span><span class="identifier">eight</span><span class="special">&gt;;</span>

<span class="comment">// `eight` is NOT a constexpr function, so can_invoke_constexpr</span>
<span class="comment">// returns `std::false_type` even for valid INVOKE arguments.</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke_constexpr</span><span class="special">(</span><span class="identifier">eight_c</span><span class="special">{},</span> <span class="number">0</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">can_invoke_constexpr</span><span class="special">(</span><span class="identifier">eight_c</span><span class="special">{},</span> <span class="keyword">nullptr</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_function_type"></a><a class="link" href="ref.html#callable_traits.ref.ref_function_type" title="function_type">function_type</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_function_type.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_function_type.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_function_type.example">Example</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">test</span><span class="special">(){</span>

    <span class="comment">// this example shows how callable_traits::function_type</span>
    <span class="comment">// bevaves consistently for many different types</span>
    <span class="keyword">using</span> <span class="identifier">type</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">function_type</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;;</span>
    <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">&amp;,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*);</span>
    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">expect</span><span class="special">,</span> <span class="identifier">type</span><span class="special">&gt;{},</span> <span class="string">""</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="keyword">auto</span> <span class="identifier">lamda</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">&amp;,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*){};</span>
    <span class="keyword">using</span> <span class="identifier">lam</span> <span class="special">=</span> <span class="keyword">decltype</span><span class="special">(</span><span class="identifier">lamda</span><span class="special">);</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">lam</span><span class="special">&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">lam</span><span class="special">&amp;&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">lam</span><span class="special">&amp;&amp;&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">lam</span> <span class="keyword">const</span> <span class="special">&amp;&gt;();</span>

    <span class="keyword">using</span> <span class="identifier">function_ptr</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(*)(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">&amp;,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*);</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">function_ptr</span><span class="special">&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">function_ptr</span><span class="special">&amp;&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">function_ptr</span><span class="special">&amp;&amp;&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">function_ptr</span> <span class="keyword">const</span> <span class="special">&amp;&gt;();</span>

    <span class="keyword">using</span> <span class="identifier">function_ref</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(&amp;)(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">&amp;,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*);</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">function_ref</span><span class="special">&gt;();</span>

    <span class="keyword">using</span> <span class="identifier">function</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">&amp;,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*);</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">function</span><span class="special">&gt;();</span>

    <span class="keyword">using</span> <span class="identifier">abominable</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">&amp;,</span> <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*)</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">abominable</span><span class="special">&gt;();</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_has_calling_convention"></a><a class="link" href="ref.html#callable_traits.ref.ref_has_calling_convention" title="has_calling_convention">has_calling_convention</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_has_calling_convention.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_has_calling_convention.example_fastcall_to_stdcall"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_has_calling_convention.example_fastcall_to_stdcall">Example
        - <code class="literal">__fastcall</code> to <code class="literal">__stdcall</code></a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">CALLABLE_TRAITS_ENABLE_STDCALL</span>
<span class="preprocessor">#define</span> <span class="identifier">CALLABLE_TRAITS_ENABLE_FASTCALL</span>

<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">has_calling_convention</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">add_calling_convention</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">remove_calling_convention</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="keyword">using</span> <span class="identifier">f</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">__fastcall</span> <span class="special">*)(</span><span class="keyword">int</span><span class="special">);</span>

    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">fastcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
    <span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">stdcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>

    <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">__stdcall</span> <span class="special">*)(</span><span class="keyword">int</span><span class="special">);</span>

    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">expect</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">stdcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
    <span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">expect</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">fastcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>

    <span class="keyword">using</span> <span class="identifier">g</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">remove_calling_convention</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">&gt;;</span>
    <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_calling_convention</span><span class="special">&lt;</span><span class="identifier">g</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">stdcall_tag</span><span class="special">&gt;;</span>

    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">stdcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_has_varargs"></a><a class="link" href="ref.html#callable_traits.ref.ref_has_varargs" title="has_varargs">has_varargs</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_has_varargs.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_has_varargs.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_has_varargs.example">Example</a>
      </h5>
<p>
        [has_varargs]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_has_void_return"></a><a class="link" href="ref.html#callable_traits.ref.ref_has_void_return" title="has_void_return">has_void_return</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_has_void_return.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_has_void_return.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_has_void_return.example">Example</a>
      </h5>
<p>
        [has_void_return]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_is_const_qualified"></a><a class="link" href="ref.html#callable_traits.ref.ref_is_const_qualified" title="is_const_qualified">is_const_qualified</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_is_const_qualified.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_is_const_qualified.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_is_const_qualified.example">Example</a>
      </h5>
<p>
        [is_const_qualified]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_is_constexpr"></a><a class="link" href="ref.html#callable_traits.ref.ref_is_constexpr" title="is_constexpr">is_constexpr</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_is_constexpr.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_is_constexpr.example_function_object"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_is_constexpr.example_function_object">Example
        - Function Object</a>
      </h5>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          When compiling in MSVC, <code class="computeroutput"><span class="identifier">is_constexpr</span></code>
          always returns <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">false_type</span></code>, because MSVC cannot compile
          the logic that normally determines this.
        </p></td></tr>
</table></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="comment">//this is a constexpr function object (non-templated)</span>
<span class="keyword">struct</span> <span class="identifier">zero</span> <span class="special">{</span>

    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span><span class="special">()()</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">is_constexpr</span><span class="special">&lt;</span><span class="identifier">zero</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">is_constexpr</span><span class="special">(</span><span class="identifier">zero</span><span class="special">{}),</span> <span class="string">""</span><span class="special">);</span>



<span class="comment">//this is a constexpr function object (templated)</span>
<span class="keyword">struct</span> <span class="identifier">subtract</span> <span class="special">{</span>

    <span class="comment">// For callable_traits::is_constexpr, generic function objects</span>
    <span class="comment">// only need to be SFINAE-friendly if the body of the operator()</span>
    <span class="comment">// function accesses member names besides "type" and "value".</span>
    <span class="comment">// Unary/binary operators and constructor calls are okay to use.</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">&gt;</span>
    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">T1</span><span class="special">{}</span> <span class="special">-</span> <span class="identifier">T2</span><span class="special">{};</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">is_constexpr</span><span class="special">&lt;</span><span class="identifier">subtract</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">is_constexpr</span><span class="special">(</span><span class="identifier">subtract</span><span class="special">{}),</span> <span class="string">""</span><span class="special">);</span>



<span class="comment">//this is NOT a constexpr function object</span>
<span class="keyword">struct</span> <span class="identifier">add</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">&gt;</span>
    <span class="keyword">auto</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">T1</span><span class="special">{}</span> <span class="special">+</span> <span class="identifier">T2</span><span class="special">{};</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">is_constexpr</span><span class="special">&lt;</span><span class="identifier">add</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">is_constexpr</span><span class="special">(</span><span class="identifier">add</span><span class="special">{}),</span> <span class="string">""</span><span class="special">);</span>

<span class="keyword">auto</span> <span class="identifier">multiply</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="identifier">t1</span><span class="special">,</span> <span class="keyword">auto</span> <span class="identifier">t2</span><span class="special">)</span> <span class="special">-&gt;</span> <span class="keyword">decltype</span><span class="special">(</span><span class="identifier">t1</span><span class="special">.</span><span class="identifier">value</span> <span class="special">*</span> <span class="identifier">t2</span><span class="special">.</span><span class="identifier">value</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">t1</span><span class="special">.</span><span class="identifier">value</span> <span class="special">*</span> <span class="identifier">t2</span><span class="special">.</span><span class="identifier">value</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">is_constexpr</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">multiply</span><span class="special">)&gt;(),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">is_constexpr</span><span class="special">(</span><span class="identifier">multiply</span><span class="special">),</span> <span class="string">""</span><span class="special">);</span>


<span class="comment">// is_constexpr will always return std::false_type when the argument</span>
<span class="comment">// is either not a literal type, or is not default constructible. Below,</span>
<span class="comment">// divide is not default constructible, so is_constexpr returns</span>
<span class="comment">// std::false_type. For literal types that are default constructible, a</span>
<span class="comment">// constexpr default constructor is assumed.</span>

<span class="keyword">struct</span> <span class="identifier">divide</span> <span class="special">{</span>

    <span class="identifier">divide</span><span class="special">()</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="keyword">constexpr</span> <span class="identifier">divide</span><span class="special">(</span><span class="keyword">int</span><span class="special">){};</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">&gt;</span>
    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">T1</span><span class="special">{}</span> <span class="special">/</span> <span class="identifier">T2</span><span class="special">{};</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">is_constexpr</span><span class="special">&lt;</span><span class="identifier">divide</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">is_constexpr</span><span class="special">(</span><span class="identifier">divide</span><span class="special">{</span><span class="number">0</span><span class="special">}),</span> <span class="string">""</span><span class="special">);</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{}</span>
</pre>
<h5>
<a name="callable_traits.ref.ref_is_constexpr.h1"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_is_constexpr.example_function_pointer"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_is_constexpr.example_function_pointer">Example
        - Function Pointer</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="comment">// NOTE: Due to non-compliance in MSVC, is_constexpr always</span>
<span class="comment">// returns std::false_type on that compiler, which causes</span>
<span class="comment">// the static asserts below to fail.</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="identifier">foo</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">int</span><span class="special">&amp;)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">bar</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">int</span><span class="special">&amp;)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
<span class="special">}</span>

<span class="comment">// for is_constexpr calls, function pointers must</span>
<span class="comment">// be passed as std::integral_constants</span>
<span class="keyword">using</span> <span class="identifier">F</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">integral_constant</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">),</span> <span class="special">&amp;</span><span class="identifier">foo</span><span class="special">&gt;;</span>
<span class="keyword">using</span> <span class="identifier">B</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">integral_constant</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(&amp;</span><span class="identifier">bar</span><span class="special">),</span> <span class="special">&amp;</span><span class="identifier">bar</span><span class="special">&gt;;</span>

<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">is_constexpr</span><span class="special">(</span><span class="identifier">F</span><span class="special">{}),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">is_constexpr</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">is_constexpr</span><span class="special">(</span><span class="identifier">B</span><span class="special">{}),</span> <span class="string">""</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">is_constexpr</span><span class="special">&lt;</span><span class="identifier">B</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_is_lvalue_qualified"></a><a class="link" href="ref.html#callable_traits.ref.ref_is_lvalue_qualified" title="is_lvalue_qualified">is_lvalue_qualified</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_is_lvalue_qualified.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_is_lvalue_qualified.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_is_lvalue_qualified.example">Example</a>
      </h5>
<p>
        [is_lvalue_qualified]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_is_reference_qualified"></a><a class="link" href="ref.html#callable_traits.ref.ref_is_reference_qualified" title="is_reference_qualified">is_reference_qualified</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_is_reference_qualified.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_is_reference_qualified.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_is_reference_qualified.example">Example</a>
      </h5>
<p>
        [is_reference_qualified]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_is_rvalue_qualified"></a><a class="link" href="ref.html#callable_traits.ref.ref_is_rvalue_qualified" title="is_rvalue_qualified">is_rvalue_qualified</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_is_rvalue_qualified.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_is_rvalue_qualified.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_is_rvalue_qualified.example">Example</a>
      </h5>
<p>
        [is_rvalue_qualified]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_is_qualified"></a><a class="link" href="ref.html#callable_traits.ref.ref_is_qualified" title="is_qualified">is_qualified</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_is_qualified.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_is_qualified.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_is_qualified.example">Example</a>
      </h5>
<p>
        [is_qualified]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_is_volatile_qualified"></a><a class="link" href="ref.html#callable_traits.ref.ref_is_volatile_qualified" title="is_volatile_qualified">is_volatile_qualified</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_is_volatile_qualified.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_is_volatile_qualified.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_is_volatile_qualified.example">Example</a>
      </h5>
<p>
        [is_volatile_qualified]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_max_arity"></a><a class="link" href="ref.html#callable_traits.ref.ref_max_arity" title="max_arity">max_arity</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_max_arity.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_max_arity.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_max_arity.example">Example</a>
      </h5>
<p>
        [max_arity]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_min_arity"></a><a class="link" href="ref.html#callable_traits.ref.ref_min_arity" title="min_arity">min_arity</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_min_arity.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_min_arity.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_min_arity.example">Example</a>
      </h5>
<p>
        [min_arity]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_qualified_function_type"></a><a class="link" href="ref.html#callable_traits.ref.ref_qualified_function_type" title="qualified_function_type">qualified_function_type</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_qualified_function_type.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_qualified_function_type.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_qualified_function_type.example">Example</a>
      </h5>
<p>
        [qualified_function_type]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_remove_calling_convention"></a><a class="link" href="ref.html#callable_traits.ref.ref_remove_calling_convention" title="remove_calling_convention">remove_calling_convention</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_remove_calling_convention.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_remove_calling_convention.example_fastcall_to_stdcall"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_remove_calling_convention.example_fastcall_to_stdcall">Example
        - <code class="literal">__fastcall</code> to <code class="literal">__stdcall</code></a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">CALLABLE_TRAITS_ENABLE_STDCALL</span>
<span class="preprocessor">#define</span> <span class="identifier">CALLABLE_TRAITS_ENABLE_FASTCALL</span>

<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">has_calling_convention</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">add_calling_convention</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">remove_calling_convention</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="keyword">using</span> <span class="identifier">f</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">__fastcall</span> <span class="special">*)(</span><span class="keyword">int</span><span class="special">);</span>

    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">fastcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
    <span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">stdcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>

    <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">__stdcall</span> <span class="special">*)(</span><span class="keyword">int</span><span class="special">);</span>

    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">expect</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">stdcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
    <span class="keyword">static_assert</span><span class="special">(!</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">expect</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">fastcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>

    <span class="keyword">using</span> <span class="identifier">g</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">remove_calling_convention</span><span class="special">&lt;</span><span class="identifier">f</span><span class="special">&gt;;</span>
    <span class="keyword">using</span> <span class="identifier">test</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">add_calling_convention</span><span class="special">&lt;</span><span class="identifier">g</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">stdcall_tag</span><span class="special">&gt;;</span>

    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">has_calling_convention</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">stdcall_tag</span><span class="special">&gt;(),</span> <span class="string">""</span><span class="special">);</span>
    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">test</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">""</span><span class="special">);</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_remove_function_const"></a><a class="link" href="ref.html#callable_traits.ref.ref_remove_function_const" title="remove_function_const">remove_function_const</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_remove_function_const.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_remove_function_const.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_remove_function_const.example">Example</a>
      </h5>
<p>
        [remove_function_const]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_remove_function_cv"></a><a class="link" href="ref.html#callable_traits.ref.ref_remove_function_cv" title="remove_function_cv">remove_function_cv</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_remove_function_cv.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_remove_function_cv.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_remove_function_cv.example">Example</a>
      </h5>
<p>
        [remove_function_cv]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_remove_member_pointer"></a><a class="link" href="ref.html#callable_traits.ref.ref_remove_member_pointer" title="remove_member_pointer">remove_member_pointer</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_remove_member_pointer.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_remove_member_pointer.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_remove_member_pointer.example">Example</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">foo</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Expect</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">test</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">U</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">remove_member_pointer</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;;</span>
    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">Expect</span><span class="special">,</span> <span class="identifier">U</span><span class="special">&gt;{},</span> <span class="string">""</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">T</span> <span class="special">=</span> <span class="keyword">int</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)(</span><span class="keyword">int</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">int</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
        <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;();</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">T</span> <span class="special">=</span> <span class="keyword">int</span> <span class="identifier">foo</span><span class="special">::*;</span>
        <span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">int</span><span class="special">;</span>
        <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">expect</span><span class="special">&gt;();</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">T</span> <span class="special">=</span> <span class="keyword">int</span><span class="special">(</span><span class="keyword">int</span><span class="special">);</span>
        <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;();</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">T</span> <span class="special">=</span> <span class="keyword">int</span><span class="special">(*)(</span><span class="keyword">int</span><span class="special">);</span>
        <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;();</span>
    <span class="special">}</span> <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">T</span> <span class="special">=</span> <span class="keyword">int</span><span class="special">(&amp;)(</span><span class="keyword">int</span><span class="special">);</span>
        <span class="identifier">test</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;();</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_remove_function_reference"></a><a class="link" href="ref.html#callable_traits.ref.ref_remove_function_reference" title="remove_function_reference">remove_function_reference</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_remove_function_reference.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_remove_function_reference.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_remove_function_reference.example">Example</a>
      </h5>
<p>
        [remove_function_reference]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_remove_varargs"></a><a class="link" href="ref.html#callable_traits.ref.ref_remove_varargs" title="remove_varargs">remove_varargs</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_remove_varargs.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_remove_varargs.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_remove_varargs.example">Example</a>
      </h5>
<p>
        [remove_varargs]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_remove_function_volatile"></a><a class="link" href="ref.html#callable_traits.ref.ref_remove_function_volatile" title="remove_function_volatile">remove_function_volatile</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_remove_function_volatile.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_remove_function_volatile.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_remove_function_volatile.example">Example</a>
      </h5>
<p>
        [remove_function_volatile]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.ref.ref_result_of"></a><a class="link" href="ref.html#callable_traits.ref.ref_result_of" title="result_of">result_of</a>
</h3></div></div></div>
<p>
        TODO
      </p>
<h5>
<a name="callable_traits.ref.ref_result_of.h0"></a>
        <span class="phrase"><a name="callable_traits.ref.ref_result_of.example"></a></span><a class="link" href="ref.html#callable_traits.ref.ref_result_of.example">Example</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">type_traits</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

<span class="keyword">using</span> <span class="identifier">expect</span> <span class="special">=</span> <span class="keyword">int</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">foo</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">test</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;;</span>
    <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">expect</span><span class="special">,</span> <span class="identifier">result</span><span class="special">&gt;{},</span> <span class="string">""</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="identifier">test</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">()&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(*)()&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(&amp;)()&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">()</span> <span class="keyword">const</span><span class="special">&gt;();</span>
    <span class="identifier">test</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(</span><span class="identifier">foo</span><span class="special">::*)()</span> <span class="keyword">const</span><span class="special">&gt;();</span>

    <span class="keyword">auto</span> <span class="identifier">x</span> <span class="special">=</span> <span class="special">[]()</span> <span class="special">-&gt;</span> <span class="keyword">int</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span> <span class="special">};</span>

    <span class="identifier">test</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">x</span><span class="special">)&gt;();</span>
<span class="special">}</span>
</pre>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Barrett Adair<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE.md or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../../src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../src/images/home.png" alt="Home"></a><a accesskey="n" href="acknowledgements.html"><img src="../../src/images/next.png" alt="Next"></a>
</div>
</body>
</html>

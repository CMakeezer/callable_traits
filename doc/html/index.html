<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Chapter&#160;1.&#160;CallableTraits</title>
<link rel="stylesheet" href="./boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="index.html" title="Chapter&#160;1.&#160;CallableTraits">
<link rel="next" href="callable_traits/tuto.html" title="Overview">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="./boost.png"></td></tr></table>
<hr>
<div class="spirit-nav"><a accesskey="n" href="callable_traits/tuto.html">Next</a></div>
<div class="chapter">
<div class="titlepage"><div>
<div><h2 class="title">
<a name="callable_traits"></a>Chapter&#160;1.&#160;CallableTraits</h2></div>
<div><div class="author"><h3 class="author">
<span class="firstname">Barrett</span> <span class="surname">Adair</span>
</h3></div></div>
<div><p class="copyright">Copyright &#169; 2016 Barrett Adair</p></div>
<div><div class="legalnotice">
<a name="callable_traits.legal"></a><p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">
        http://www.boost.org/LICENSE_1_0.txt </a>)
      </p>
</div></div>
</div></div>
<div class="toc">
<p><b>Table of Contents</b></p>
<dl class="toc">
<dt><span class="section"><a href="index.html#callable_traits.moti">Motivation</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#callable_traits.tenr">10 reasons to use CallableTraits</a></span></dt>
<dt><span class="section"><a href="index.html#callable_traits.sugr">Use case example: <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>
      sugar</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="callable_traits/tuto.html">Overview</a></span></dt>
</dl>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="callable_traits.moti"></a>Motivation</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="index.html#callable_traits.tenr">10 reasons to use CallableTraits</a></span></dt>
<dt><span class="section"><a href="index.html#callable_traits.sugr">Use case example: <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>
      sugar</a></span></dt>
</dl></div>
<p>
      The complexity of callable types in C++ is extensive:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          function types
        </li>
<li class="listitem">
          function pointers
        </li>
<li class="listitem">
          function references
        </li>
<li class="listitem">
          objects with <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
        </li>
<li class="listitem">
          objects with function pointer conversions
        </li>
<li class="listitem">
          <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html" target="_top">"abominable"
          function types</a>
        </li>
<li class="listitem">
          pointers to member data
        </li>
<li class="listitem">
          pointers to member functions
        </li>
<li class="listitem">
          qualified overloads of member functions: <code class="computeroutput"><span class="keyword">const</span></code>,
          <code class="computeroutput"><span class="keyword">volatile</span></code>, <code class="computeroutput"><span class="special">&amp;</span></code>,
          <code class="computeroutput"><span class="special">&amp;&amp;</span></code>
        </li>
<li class="listitem">
          C-style varargs (<code class="computeroutput"><span class="special">...</span></code>)
        </li>
<li class="listitem">
          calling conventions (<code class="computeroutput"><span class="identifier">__cdecl</span></code>,
          <code class="computeroutput"><span class="identifier">__stdcall</span></code>, <code class="computeroutput"><span class="identifier">__fastcall</span></code>, <code class="computeroutput"><span class="identifier">pascal</span></code>,
          etc.)
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">noexcept</span></code> (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0012r1.html" target="_top">part
          of the function type system in C++17</a>)
        </li>
</ul></div>
<p>
      CallableTraits provides a comprehensive, uniform, and modern type-level interface
      for the manipulation and inspection of callable types in C++. By filling the
      gaps where existing library solutions fall short, CallableTraits aims to provide
      such an exhaustive interface for the features listed above that libary writers
      will <span class="bold"><strong>never again</strong></span> need to specialize templates
      for callable types. With CallableTraits, library writers should never need
      to write a template like this one:
    </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Ret</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span><span class="special">...</span> <span class="identifier">Args</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">foo</span><span class="special">&lt;</span><span class="identifier">Ret</span><span class="special">(</span><span class="identifier">T</span><span class="special">::*)(</span><span class="identifier">Args</span><span class="special">...,</span> <span class="special">...)</span> <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="special">&amp;&amp;&gt;{</span>
        <span class="comment">//...</span>
<span class="special">};</span>
</pre>
<p>
      Several library solutions exist to manipulate these types, or to abstract away
      their complexities. However, these solutions are occasionally inflexible or
      lacking in features, especially regarding function objects/lambdas. In CallableTraits,
      function pointers, function references, function types, abominable function
      types, member function pointers, member data pointers, function objects/lambdas,
      and references/pointers/smart pointers thereof are generally interchangeable.
    </p>
<p>
      The use cases for CallableTraits are closely related to those of <a href="http://www.boost.org/doc/libs/1_60_0/libs/type_traits/doc/html/boost_typetraits/reference/function_traits.html" target="_top">function_traits</a>
      and <a href="http://www.boost.org/doc/libs/1_60_0/libs/function_types/doc/html/index.html" target="_top">FunctionTypes</a>.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.tenr"></a>10 reasons to use CallableTraits</h3></div></div></div>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            CallableTraits' template aliases and <code class="computeroutput"><span class="keyword">constexpr</span></code>
            <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">integral_constant</span></code> functions are preferable
            to <code class="computeroutput"><span class="keyword">typename</span> <span class="identifier">foo</span><span class="special">::</span><span class="identifier">type</span></code>
            and <code class="computeroutput"><span class="identifier">foo</span><span class="special">::</span><span class="identifier">value</span></code>
          </li>
<li class="listitem">
            CallableTraits offers a familar, consistent interface for the synthesis
            and decomposition of callable types
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                  e.g. <code class="computeroutput"><span class="identifier">callable_traits</span><span class="special">::</span><span class="identifier">remove_const_qualifier</span></code>
                  parallels <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">remove_const</span></code>
                </li></ul></div>
          </li>
<li class="listitem">
            universal references are accepted everywhere, so you don't need to worry
            about using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">remove_reference</span></code> first
          </li>
<li class="listitem">
            function object pointers/ pointers are accepted (when <code class="computeroutput"><span class="identifier">INVOKE</span></code>
            is not an immediate concern)
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">arg_at</span><span class="special">&lt;</span><span class="number">2</span><span class="special">,</span> <span class="identifier">Callable</span><span class="special">&gt;</span></code> is better than <code class="computeroutput"><span class="keyword">typename</span>
            <span class="identifier">function_traits</span><span class="special">&lt;</span><span class="identifier">Callable</span><span class="special">&gt;::</span><span class="identifier">arg2_type</span></code>
          </li>
<li class="listitem">
            function objects are first-class citizens in CallableTraits
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                  e.g. <code class="computeroutput"><span class="identifier">result_of</span></code>
                  can accept a function object
                </li></ul></div>
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">is_constexpr</span></code> lets you
            check whether a function, member function, or function object is <code class="computeroutput"><span class="keyword">constexpr</span></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">can_invoke</span></code> lets you test
            <code class="computeroutput"><span class="identifier">INVOKE</span></code>-ability at compile-time
            using value semantics
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">can_invoke_constexpr</span></code>
            adds a <code class="computeroutput"><span class="keyword">constexpr</span></code>-ness check
            to <code class="computeroutput"><span class="identifier">can_invoke</span></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">min_arity</span></code> can be used
            to detect default arguments of a function object
          </li>
</ol></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="callable_traits.sugr"></a>Use case example: <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>
      sugar</h3></div></div></div>
<p>
        At the time of this writing, there are 260 <a href="http://stackoverflow.com/search?q=convert+std%3A%3Abind+to+std%3A%3Afunction" target="_top">search
        results</a> on Stack Overflow concerning the conversion from <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span></code>
        to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>. There are 336 <a href="http://stackoverflow.com/search?q=convert+lambda+to+std%3A%3Afunction" target="_top">search
        results</a> concerning the conversion of lambdas to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>.
        With this example, we'll kill both birds with the same stone. The <code class="computeroutput"><span class="identifier">make_function</span></code> function defined below will
        leverage CallableTraits to...
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            Create an <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
            where T is not explicitly supplied by the user
          </li>
<li class="listitem">
            Create an <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
            where T is the deduced "signature" of an <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">placeholders</span></code>
            expression.
          </li>
</ol></div>
<p>
        Without real-world context, <code class="computeroutput"><span class="identifier">make_function</span></code>
        may seem rather silly to those who are aware of the runtime costs of type
        erasure. However, whenever <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>
        is required by some 3rd party API, this example makes a bit more sense.
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">functional</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">callable_traits</span><span class="special">/</span><span class="identifier">callable_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">example_library</span> <span class="special">{</span>

    <span class="keyword">namespace</span> <span class="identifier">ct</span> <span class="special">=</span> <span class="identifier">callable_traits</span><span class="special">;</span>

    <span class="comment">//`make_function` turns a non-overloaded callable into a type-erased std::function object</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="keyword">inline</span> <span class="keyword">decltype</span><span class="special">(</span><span class="keyword">auto</span><span class="special">)</span> <span class="identifier">make_function</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">)</span> <span class="special">{</span>

        <span class="comment">// callable_traits::function_type decays any non-overloaded callable type to </span>
        <span class="comment">// a plain function type, which is structured in terms of INVOKE.</span>

        <span class="keyword">using</span> <span class="identifier">signature</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">function_type</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&amp;&amp;&gt;;</span>
        <span class="keyword">using</span> <span class="identifier">result_type</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">signature</span><span class="special">&gt;;</span>
        <span class="keyword">return</span> <span class="identifier">result_type</span><span class="special">{</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">t</span><span class="special">)</span> <span class="special">};</span>
    <span class="special">}</span>

    <span class="comment">//this `make_function` overload turns a bind expression into a type-erased std::function object</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">First</span><span class="special">,</span> <span class="keyword">typename</span><span class="special">...</span> <span class="identifier">Others</span><span class="special">&gt;</span>
    <span class="keyword">inline</span> <span class="keyword">decltype</span><span class="special">(</span><span class="keyword">auto</span><span class="special">)</span> <span class="identifier">make_function</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">,</span> <span class="identifier">First</span><span class="special">&amp;&amp;</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">Others</span><span class="special">&amp;&amp;...</span> <span class="identifier">others</span><span class="special">)</span> <span class="special">{</span>

        <span class="comment">// callable_traits::bind is essentially a compile-time parser of placeholders</span>
        <span class="comment">// expressions, for the purpose of retaining more type information than</span>
        <span class="comment">// std::bind normally allows - specifically, callable_traits::bind is used to</span>
        <span class="comment">// determine the de-facto signature of the std::bind return type, with special</span>
        <span class="comment">// considerations for conversions between reused placeholders and nested</span>
        <span class="comment">// placeholder expressions. For the sake of convenience, callable_traits::bind</span>
        <span class="comment">// is also a thin forwarding wrapper around std::bind (which is the only true </span>
        <span class="comment">// runtime element in CallableTraits).</span>

        <span class="keyword">using</span> <span class="identifier">bind_expr</span> <span class="special">=</span> <span class="keyword">decltype</span><span class="special">(</span><span class="identifier">ct</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">t</span><span class="special">),</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">First</span><span class="special">&gt;(</span><span class="identifier">first</span><span class="special">),</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Others</span><span class="special">&gt;(</span><span class="identifier">others</span><span class="special">)...</span>
        <span class="special">));</span>

        <span class="keyword">using</span> <span class="identifier">signature</span> <span class="special">=</span> <span class="identifier">ct</span><span class="special">::</span><span class="identifier">function_type</span><span class="special">&lt;</span><span class="identifier">bind_expr</span><span class="special">&gt;;</span>
        <span class="keyword">using</span> <span class="identifier">result_type</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">signature</span><span class="special">&gt;;</span>

        <span class="keyword">return</span> <span class="identifier">result_type</span><span class="special">{</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">t</span><span class="special">),</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">First</span><span class="special">&gt;(</span><span class="identifier">first</span><span class="special">),</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Others</span><span class="special">&gt;(</span><span class="identifier">others</span><span class="special">)...</span>
        <span class="special">)};</span>
    <span class="special">}</span>
<span class="special">}</span>

<span class="comment">//client code starts here</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cassert</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">example_library</span><span class="special">;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">placeholders</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">add</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">j</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">i</span> <span class="special">+</span> <span class="identifier">j</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">struct</span> <span class="identifier">adder</span> <span class="special">{</span>

    <span class="keyword">int</span> <span class="identifier">eval</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">j</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">i</span> <span class="special">+</span> <span class="identifier">j</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

    <span class="comment">//function pointer</span>
    <span class="keyword">auto</span> <span class="identifier">f</span> <span class="special">=</span> <span class="identifier">make_function</span><span class="special">(&amp;</span><span class="identifier">add</span><span class="special">);</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">f</span><span class="special">(</span><span class="number">99</span><span class="special">,</span> <span class="number">1</span><span class="special">)</span> <span class="special">==</span> <span class="number">100</span><span class="special">);</span>

    <span class="comment">//function reference</span>
    <span class="identifier">f</span> <span class="special">=</span> <span class="identifier">make_function</span><span class="special">(</span><span class="identifier">add</span><span class="special">);</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">f</span><span class="special">(</span><span class="number">99</span><span class="special">,</span> <span class="number">1</span><span class="special">)</span> <span class="special">==</span> <span class="number">100</span><span class="special">);</span>

    <span class="comment">//member function pointer (bound to object)</span>
    <span class="identifier">f</span> <span class="special">=</span> <span class="identifier">make_function</span><span class="special">(&amp;</span><span class="identifier">adder</span><span class="special">::</span><span class="identifier">eval</span><span class="special">,</span> <span class="identifier">adder</span><span class="special">{},</span> <span class="identifier">_1</span><span class="special">,</span> <span class="identifier">_2</span><span class="special">);</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">f</span><span class="special">(</span><span class="number">99</span><span class="special">,</span> <span class="number">1</span><span class="special">)</span> <span class="special">==</span> <span class="number">100</span><span class="special">);</span>

    <span class="comment">//lambda</span>
    <span class="identifier">f</span> <span class="special">=</span> <span class="identifier">make_function</span><span class="special">([](</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">j</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">i</span> <span class="special">+</span> <span class="identifier">j</span><span class="special">;</span>
    <span class="special">});</span>

    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">f</span><span class="special">(</span><span class="number">99</span><span class="special">,</span> <span class="number">1</span><span class="special">)</span> <span class="special">==</span> <span class="number">100</span><span class="special">);</span>
<span class="special">}</span>
</pre>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer"></div></td>
</tr></table>
<hr>
<div class="spirit-nav"><a accesskey="n" href="callable_traits/tuto.html">Next</a></div>
</body>
</html>
